[TOC]



# 前文提要

本规范归属于若慧电子科技

本规范参考MISRA2012静态代码规则

由于每位工程师都有自己的逻辑思路与编程习惯，所以需要在保留工程师自我规则的同时进行代码规范，这有益于代码的继承和易读性。

# 1. **程序排版**

## 1.1基本要求

- Tab缩进统一为标准的4个空格
- 行尾不保留空格

- 程序块应采用Tab缩进风格编写

- 每行代码长度不得大于120字符长度

## 1.2 程序块之间应预留空行

程序块包含但不仅限于：头文件引入，宏定义，全局变量定义，命名空间，函数，结构体定义等。

程序块之间预留空行，使代码清晰易读

```c
void example_fun(void) {
... // program code
}

void example_fun1(void) {
... // program code
}
```

## 1.3 长语句与长表达式

较长的语句（>120字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行4空格缩进，使排版整齐，语句可读，多行间用’\’分割。（运算符放行尾）

```c
len = EXAMPLE_PARAM1 + \
 EXAMPLE_PARAM2 + \
 EXAMPLE_PARAM3 + \
 EXAMPLE_PARAM4;

sprintf(data, "G2O CollectData id:%d, clusterId:%d, pose:(%f,%f,%f)\n", \
 EXAMPLE_PARAM1, EXAMPLE_PARAM2, EXAMPLE_PARAM3, \
 EXAMPLE_PARAM4, EXAMPLE_PARAM5);
```

## 1.4 短语句

不允许把多个短语句写在一行中，即一行只写一条语句。

错误示例：

```c
unsigned char param1;unsigned int param2;
param1=1;param2=2;
```

正确示例：

```c
unsigned char param1;
unsigned int param2;
param1 = 1;
param2 = 2;
```

## 1.5 条件、循环语句

if、for、do、while、case、switch、default等语句自占一行，且if、for、do、while等语句的执行语句部分无论多少都要加括号{}。

错误示例：

```c
if (param==true) 
    return;
```

正确示例：

```c
if (pdata == NULL) {
	return;
}
```

## 1.6 语句对齐

​	语句对齐基本仅使用空格键，为避免不同的编辑器编辑程序时，因Tab键所设置的空格数目不同而造成程序混乱的情况，在使用Tab键前需按照 > **1.1基本要求** 对编辑器进行设置。

## 1.7 函数、过程、结构体等语句块

函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格，case语句下的情况处理语句也要遵从语句缩进要求。

## 1.8 程序块分界符

程序块的分界符‘{’和前面语句同一行（函数的‘{’除外，需要另起新行），‘}’应独占一行，同时与引用它们的语句左对齐。

在函数体的开始、类的定义、结构的定义、枚举的定义以及if、for、do、while、switch、case语句中的程序都要采用如上的缩进方法，且后面留一空格，同行‘{’前也预留一个空格。另外，else不单独起新行。

错误示例：

```c
for (...)
{
... // program code
}

if (...)
{
... // program code
}
else
{
... // program code
}

void example_foo( void )
    {
     ... // program code
    }
```

正确示例：

```c
for (...) {
... // program code
}

if (...) {
... // program code
} else {
... // program code
}

void example_foo( void )
{
... // program code
}
```

## 1.9 操作符前后空格

为使代码变的更加清晰，通常采用较为松散的排版及编写方式：

在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格； 进行非对等操作时，如果是关系密切的立即操作符（如－>），后不应加空格。由于留空格所产生的清晰性是相对的，所以，在已经非常清晰的语句中没有必要再留空格，如果语句已足够清晰则括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在 C/C++语言中括号已经是最清晰的标志了。

在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。

- 逗号、分号只在后面加空格。

```c
int a, b, c;
```

- 比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&&"、"&"，位域操作符"<<"、"^"等双目操作符的前后加空格。

```c
if (a >= b){
	a = b + c;
	a *= 2;
	a = b ^ 2;
}
```

- "!"、"~"、"++"、"--"、"&"（地址运算符）等单目操作符前后不加空格。

```c
*p = 'a'; // 内容操作"*"与内容之间
flag = !isEmpty; // 非操作"!"与内容之间
p = &mem; // 地址操作"&" 与内容之间
i++; // "++","--"与内容之间
```

- "->"、"."前后不加空格。

```c
p->id = pid; // "->"指针前后不加空格
```

- if、for、while、switch 等与后面的括号间应加空格，使 if 等关键字更为突出、明显。

```c
if (a >= b && c > d)
```

- 如果逻辑条件判断过多，可以将表达式拆成多个变量关系表示，使得逻辑看上去更加清晰，如：

```c
if (val < MAX_VALUE_FIRST && val > MIN_VALUE_FIRST &&
val2 < MAX_VALUE_SECOND && val2 > MIN_VALUE_SECOND) {
... // program code
}
可以写成：
bool is_val_valid = (val < MAX_VALUE_FIRST && val > MIN_VALUE_FIRST) ? true : false;
boolis_val2_valid = (val2 < MAX_VALUE_SECOND && val2 > MAX_VALUE_SECOND) ? true : false;
if (is_val_valid && is_val2_valid) {
... // program code
}
```

## 1.10 commit格式

代码入库的commit信息中，行尾不允许空格，不允许有tab，描述尽量用英文，在用英文无法描述清楚的情况下，可以用中文。

具体格式为：小标题+“:”+描述，然后空一行，再写修改点。修改点按“1，2，3 ...”罗列。

示例：

enable adc: enable power adc

1. add power check
2. change adc status

# 2.程序注释

## 2.1 基本要求

- 程序有效注释量建议在 20％以上

- 尽量使用英文注释，描述不清可以使用中文，

- 文件保存为UTF8格式。

说明：注释的原则是有助于对程序的阅读理解，在该加的地方都加了，注释不宜太多也不能太少，注释语言必须准确、易懂、简洁，重点解释是什么，而不是解释怎么做，怎么做可以通过代码解释。

## 2.2 头部说明

新增文件建议在头文件中加入文件头

文件头的格式无严格格式，示例：

```c
/********************************************************************************
* @file adc.c
* @author sunshine.su
* @version V1.0.0
* @date 13-12-2020
* @brief driver for analog input
*********************************************************************************/
```

## 2.3 函数说明

函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值等。

如果函数本身比较简单易懂，函数名称足够说明函数的作用，可以不加注释

示例:

```c
/**
 * @description: MCUA and MCUB param contrast
 * @param {uint8_t*} frame: another MCU info data
 * @param {int32_t} length: data length
 * @return {*}
 */
static void module_param_check(uint8_t* frame, int32_t length)
```

## 2.4 注释实时性

要求注释在写代码或修改代码时就应该添加或者修改，不再有用或不再需要的注释要及时**删除**

废弃的代码原则上要求删除，不做注释

## 2.5 准确注释

注释的内容要清楚、明了，含义准确，防止**注释多义**。

注释原则上不允许缩写，若有缩写，应在缩写之前已对缩写内容进行说明

**在代码的功能、意图层次上进行注释，提供有用、额外的信息，不应存在意义不大的注释**

## 2.6 注释位置

注释应与其描述的代码相近，对代码的注释应放在其上方或右方（对单条语句的注释）相邻位置，建议放在代码上方，不可放在下面，如放于上方则需与其上面的代码用空行隔开。

示例：

```c
/* configure CAN1_Rx as alternate function push-pull */
gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_12);
    
/* configure CAN1_Tx as alternate function push-pull */
gpio_output_options_set(GPIOB, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_13);
```

段注释内不应包含行注释

错误示例：

```c
/*
//error
*/
```

## 2.7 变量、常量、数据结构的注释

对于所有有物理含义的变量、常量、数据结构声明(包括数组、结构、类、枚举等)，，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其物理含义。变量、常量、宏的注释。

示例：

```c
/* maximum number of security features that the user can set */
#define MAX_USER_SAFE_NUM   20

/* User-definable and system security function type definition */
enum {
    SAFE_TYPE_ESTOP = 0,
    SAFE_TYPE_SPEED_MONITOR,
    SAFE_TYPE_RELAY_MONITOR,
    SAFE_TYPE_USER,
    SAFE_TYPE_NUM,
    SAFE_TYPE_FAULT = 0X80,
    SAFE_TYPE_CAN,
    SAFE_TYPE_SYNC,
};
```

## 2.8 注释排版

注释与所描述内容进行同样的缩排。

注释内容与注释符之间前后各留一个空格。

错误示例：

```c
void example_func(void)
{
/* set first param */
	int a;
	/* set second param */
	char b;
}
```

正确示例：

```c
void example_func(void)
{
	/* set first param */
	int a;
	
	/* set second param */
	char b;
}
```

2.9 注释风格

注释格式尽量统一，建议代码上方注释使用“/\* …… \*/”

注释应考虑程序易读及外观排版的因素，注释采用英文，防止中文注释的乱码显示问题。

通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构， 最好的注释就是代码本身。

避免在一行代码或表达式的中间插入注释。

# 3.命名规则

## 3.1 命名准确

标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。

说明：较短的单词可通过去掉“元音”形成缩写如（message 可缩写为 msg ;）；较长的单词可取单词的头几个字母形成缩写；一些单词有大家公认的缩写。



## 3.2命名风格

对于一个工程而言，命名风格应保持一致。

自己特有的命名风格在符合所有项目和工程的命名规则的前提才被允许使用，若中途加入工程，命名规则应与工程原规则保持一致。

一旦使用自己的特有命名风格，必须要从始至终的使用，不可变化。

## 3.3变量命名

对于变量命名，禁止取单个字符（如 i、j、k...），建议除了要有具体含义外，还能表明其变量类型、数据类型等，但 i、j、k 作局部循环变量是允许的。

原则上变量名的长度与它的作用域的大小成正相关，也就是如果一个变量的作用域比较大，那么在这个作用域内的变量就会比较多，为了避免冲突便于区分，变量名就应该比较长。反之亦然。

变量名应当采用下划线命名规则，如cur_frame_pos, new_label

局部变量命名应当简短、有用，如error, client，tmp

全局变量应当增加描述性内容，如count_active_users而不是cntusr.

## 3.4 函数/类/结构体/枚举命名

自定义结构体，枚举均采用下划线命名方式

枚举值，宏均采用全**大写**方式命名，单词之间采用下划线分隔

```c
typedef enum {
    SAFE_CODE_SYNC = 1,
    SAFE_CEDE_FAULT,
    SAFE_CODE_CAN,
    SAFE_CODE_USER_CODE_START = 0X20,
    SAFE_CODE_USER_CODE_END   = 0XFF,
} safe_code_e;

typedef struct {
    char     safe_name[MAX_SAFE_NAME];
    uint8_t  safe_code;
    bool     safe_state_en;
    uint8_t  sate_type;
    uint8_t  action_code;
    uint16_t delay_time;
    uint16_t option_time;
} safe_state_info_t;

void safe_state_output(module_state_e state)
```

## 3.5注意事项

除非必要，不要用数字或较奇怪的字符来定义标识符。

在同一软件产品内，应规划好接口部分标识符（变量、结构、函数及常量）的命名，防止编译、链接时产生冲突。

用正确的反义词组命名具有互斥意义的变量或相反动作的函数等

一些在软件中常用的反义词组：

add / remove 						begin / end 			create / destroy

insert / delete 						first/ last 				request / release

increment / decrement 		·put / get 				 add / delete

lock / unlock 						 open / close 	       min / max

nex / old 								start / stop 		     next / previous

source / target 					   show / hide 		   send / receive

head / tail 							   cut / paste 	        up / down

# 4可读性

## 4.1 运算符优先级

注意运算符的优先级，并用括号明确表达式的操作顺序，避免使用默认优先级。

防止阅读程序时产生误解，防止因默认的优先级与设计思想不符而导致程序出错。

示例：

```c
word = (high << 8) | low (1)
if ((a | b) && (a & c)) (2)
if ((a | b) < (c & d)) (3)
    
//如果书写为
high << 8 | low
a | b && a & c
a | b < c & d
    
//由于
high << 8 | low = (high << 8) | low,
a | b && a & c = (a | b) && (a & c)，
//(1)(2)不会出错，但语句不易理解；
a | b < c & d = a | （b < c） & d，//(3)造成了判断条件出错。
```

## 4.2 数字标识符

数字标识符在原则上禁止使用

**避免使用不易理解的数字，即魔鬼数字(Magic Number)**，应用有意义的标识来替代。涉及物理状态或者含有物理意义的常量，不应直接使用数字，必须用有意义的枚举或宏来代替。

错误示例：

```c
if ( a == 3){
	//code
}else if ( a == 2){
	//code
}
```

正确示例：

```C
#define RUN  (3)
#define SAFE (2)
if ( a == RUN){
	//code
}else if ( a == SAFE){
	//code
}
```

## 4.3 代码关联性

程序中关系较为紧密、具有关联性的代码应尽可能靠近

不规范示例：

```c
a_t.length = 1;
str = "test";
a_t.width = 2;
```

规范示例：

```c
a_t.length = 1;
a_t.width = 2;
str = "test";
```

## 4.3技巧性代码

避免利用不易理解的技巧性代码，除非很有必要

注意：高技巧语句并不等于高效率程序，通常都会带来阅读的困难

如：

```c
* ptr ++ += 1;
* ++ptr += 1;
应分别改为如下:
*ptr += 1;
ptr++; // 此二语句功能相当于“ *cnt ++ += 1; ”
++ ptr;
*ptr+= 1; // 此二语句功能相当于“ * ++cnt += 1;
```

# 5.变量

## 5.1公共变量

- 各大模块之间最大的耦合点就是公共变量，所以应避免使用没有必要的公共变量

- 公共变量定义时应明确其含义、作用及取值范围等信息

- 公共变量赋值时应仔细检查是否有不合理或越界值，建议对公共变量的写成函数，并在函数内进行合法性检查。

## 5.2同名变量

应避免局部变量与全局变量的同名

## 5.3变量调用

严禁使用未经初始化或赋值的变量作为运算的右值

构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的公共变量，防止多个不同模块或函数都可以修改、创建同一公共变量的现象,降低公共变量耦合度。

# 6.宏

## 6.1运算宏

用宏定义表达式时，要使用完备的括号

不规范示例：

```c
#define RECTANGLE_AREA(a, b) a * b
#define RECTANGLE_AREA(a, b) (a * b)
#define RECTANGLE_AREA(a, b) (a) * (b)
```

规范示例：

```c
#define RECTANGLE_AREA(a, b) ((a) * (b))
```

## 6.2代码块宏

宏定义一段代码或多条表达式时，应将其放在大括号中

```c
#define SAFE_PARAM_BACKUP_WRITE                                                                                \
    {                                                                                       				 \
        fmc_erase_page_by_address((uint32_t)(SAFE_PARAM_BACKUP_ADDR), 1);                                      \
        flash_write_by_addr(( uint8_t* )&spc100.active_param, SAFE_PARAM_BACKUP_ADDR, sizeof(module_param_t)); \
    }
```

## 6.2宏参数

使用具有参数的宏时，传参时应不允许参数发生变化

```c
#define SQUARE(a) ((a) * (a))
{
    int a = 5;
    int b;
    b = SQUARE(a++); // 结果：a = 7，即执行了两次增 1。
}
```

正确的用法是：

```c
b = SQUARE(a);
a++; // 结果：a = 6，即只执行了一次增 1。
```

# 7.软件质量

## 7.1质量优先级(高->低)

（1）正确性，指程序要实现设计要求的功能。

（2）稳定性、安全性，指程序稳定、可靠、安全。

（3）可测试性，指程序要具有良好的可测试性。

（4）规范/可读性，指程序书写风格、命名规则等要符合规范。

（5）全局效率，指软件系统的整体效率。

（6）局部效率，指某个模块/子模块/函数的本身效率。

（7）个人表达方式/个人方便性，指个人编程习惯。

## 7.2指针操作

指针应先赋值后访问，并进行空指针保护

## 7.3内存操作

- 只引用属于自己的存贮空间

- 防止引用已经释放的空间

- 内存及时释放：过程/函数中分配的内存，在过程/函数退出之前要释放。如果该内存作为出参传递，需要关注函数下游使用完后，是否释放相应内存，指针释放时，一定要把指针置为NULL，避免野指针带来的问题。原则上malloc/free要配套使用。
- 防止内存操作越界，应有合法性检查

## 7.4文件句柄及时关闭

过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。

说明：分配的内存不释放以及文件句柄不关闭，是较常见的错误，而且稍不注意就有可能发生。这类错误往往会引起很严重后果，且难以定位

示例：下函数在退出之前，没有把分配的内存释放。

```c
typedef unsigned char BYTE;
int example_foo(BYTE len, BYTE *code)
{
	BYTE *buf;
	buf= (BYTE *) malloc (MAX_GT_LENGTH);
	... //program code, include checkbuf if or not NULL.
	/* global title length error */
	if (len > MAX_GT_LENGTH) {
		return GT_LENGTH_ERROR; // 忘了释放buf
	}
	... // other program code
}
```

应修改为：

```c
int example_foo(BYTE len, BYTE *code)
{
	BYTE *buf;
	buf= (BYTE *) malloc (MAX_GT_LENGTH);
	... // program code, include checkbuf if or not NULL.
	/* global title length error */
	if (len > MAX_GT_LENGTH) {
		free( buf); // 退出之前释放buf
		return GT_LENGTH_ERROR;
	}
	... // other program code
}
```

## 7.5严禁随意修改关键变量

不能随心所欲地更改不属于自己模块的有关设置如常量、数组的大小等

不能随意修改与其他模块的接口

## 7.6初始化变量

系统运行前，要初始化有关变量及运行环境，防止未经初始化的变量被引用，可以引起无法预期的结果

## 7.7差一错误和除零保护

- 把"<="误写成“<”或">="误写成">"等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查

- 当分母有可能为零时，在进行除法和求余操作时，原则上必须进行除零保护。

## 7.8操作符检查

要时刻注意易混淆的操作符。当编完程序后，应从头至尾检查一遍这些操作符，以防止拼写错误。

如C/C++中的“=”与“==”, “|”与“||”，“&”与“&&”等，若拼写错了，编译器不一定能够检查出来

## 7.9分支语句

if 语句，对没有 else 分支的语句要小心对待, 谨防逻辑错误；

switch 语句必须有 default分支，每个case下原则必须要有break或者return。多个case合并使用必须要有注释说明。

## 7.10 goto语句

goto 语句会破坏程序的结构性，所以除非确实需要，最好不使用 goto 语句

## 7.11表达式的上下溢出

如下程序将造成变量下溢。

unsigned char size;

while (size-- >= 0) { // 将出现下溢

... // program code

}

当 size 等于 0 时，再减 1 不会小于 0，而是 0xFF，故程序是一个死循环。应如下修改。

char size; // 从 unsigned char 改为 char

while (size-- >= 0) {

... // program code

}

整形数据推荐使用int，避免带来使用如char变量，而后期扩位修改的问题

## 7.12变量边界值

C 语言中字符型变量，有效值范围为-128 到 127。故以下表达式的计算存在一定风险：

```c
char chr = 127;
int sum = 200;
chr += 1; // 127 为 chr 的边界值，再加 1 将使 chr 上溢到-128，而不是 128。
sum += chr; // 故 sum 的结果不是 328，而是 72。
```

## 7.13局部变量的引用

禁止返回或引用局部变量的指针

## 7.14 const

const进行修饰的变量的值在程序的任意位置将不能再被修改，利用这一特性，防止程序的意外修改导致的逻辑错误。

## 7.14 多线程

线程使用中要注意，如何控制线程的调度和阻塞，防止出现分支返回而遗忘释放锁，导致死锁的问题。

如果某个变量多个线程会访问到，一定要考虑变量的安全访问性，一般用LOCK锁机制来控制线程安全性。一定要保证不要有死锁机制。如果coredump发生在某个变量的不同操作处，需要首先排查是否是多线程访问未加保护而导致的内存崩溃。

注意锁不能锁住线程太久，避免出现线程堵塞的情况。

# 8.MISRA规则

MISRA规则分为强制的、必需的和建议的三种。：

建议的可以不做要求

强制的必须执行

必需的规则在不符合公司编程情况时可酌情背离

## 8.1强制的规则 MISRA Mandatory Rules

<img src="C:\Users\suxd\AppData\Roaming\Typora\typora-user-images\image-20230925184019018.png" alt="image-20230925184019018" style="zoom: 67%;" />

### 8.1.1 Rule-9.1

The value of an object with automatic storage duration shall not be read before it has been
set

#### 8.1.1.1 避免在初始化之前使用 [MISRA2012-RULE-9_1-2]

该规则检查变量是否在初始化之前使用

```c
static void useParameter(int *pi)
{
	int j = *pi;
}

static void usageOfUninializedVariablePassedToMethodByAddress()
{
	int i;
	useParameter(&i); // VIOLATION
}
```

```c
static void pointerDerefInLhsOfDefinition()
{
    int* notInitializedPointer;
    *notInitializedPointer = 0; // VIOLATION
}
```

### 8.1.2 Rule-12.5

The size of operator shall not have an operand which is a function parameter declared as ’array of type’

parasoft cpptest MISRA2012规则对此条未见规定 可酌情考虑此项规则

### 8.1.3 Rule-13.6

The operand of the sizeof operator shall not contain any expression which has potential side-effects.

本条规则拥有三条细化规则：

#### 8.1.3.1  sizeof 操作符的参数不应该是任何含副作用的表达式 [MISRA2012-RULE-13_6_a-2]

```c
int glob;

int fun_with_se(){
    glob++; // side-effect
    return glob;
}

void foo1(int i){
    int j, k, l, m;
    j = sizeof(k = 2);         // 违规 - k is not set to 2
    l = sizeof(i++);           // 违规 - i is not incremented
    m = sizeof(fun_with_se()); // 违规 - glob is not incremented
}
```

```c
int fun_without_se(){
    // no side-effect
    return 1;
}

void foo1(int i){
    int j, k, l, m, n, o;
    volatile int vol;
    k = 2;
    j = sizeof(k);                // OK
    i++;
    l = sizeof(i);                // OK
    // examples of correct code
    m = sizeof(fun_without_se()); // OK
    n = sizeof(int);              // OK
    o = sizeof(vol);              // OK - volatile objects are permitted
}
```

#### 8.1.3.2 不应该在sizeof操作符的操作数中访问由一个不稳定的数值指定的对象 [MISRA2012-RULE-13_6_b-2]

```c
struct S {
    volatile int mv;
};

void foo(volatile int v1){
    volatile int* vp1;
    int* volatile pv1;
    struct S s;
    int a[5];
    
    sizeof(v1 + 1);       // Violation  
    sizeof((*pv1)/8);     // Violation  
    sizeof(1 + vp1[2]);   // Violation  
    sizeof(a[v1]);        // Violation  
    sizeof(!s.mv);        // Violation
    sizeof(char [v1]);    // Violation
}
```

```c
struct S {
    volatile int mv;
};

void foo(volatile int v1){
    volatile int* vp1;
    int* volatile pv1;
    struct S s;
    volatile int av[5];
    
    sizeof(v1);           // OK - Exception
    sizeof(vp1 + 1);      // OK - pointer to volatile object  
    sizeof(*pv1);         // OK - Exception   
    sizeof(av[5]);        // OK - Exception
    sizeof(struct S);     // OK
}
```

#### 8.1.3.3 函数调用不得是 sizeof 运算符的操作数 [MISRA2012-RULE-13_6_c-2]

```c
int glob;

int foo1() {           // 函数 'foo1' 引起副作用
    glob = 100;
    return glob;
}

int foo2();            // 函数 'foo2' 可能或不会引起副作用

int foo3(int x) {      //  函数 'foo3' 不会引起副作用
    return x*x;
}

void foo_s() {
    unsigned int ui;
    ui = sizeof(foo1());             // 违规
    ui = sizeof(foo2());             // 违规
    ui = sizeof(foo3(2));            // 违规
    ui = sizeof(printf("message"));  // 违规
}
```

禁止在 sizeof 操作符的操作数中使用函数调用

### 8.1.4 Rule-17.3

A function shall not be declared implicitly.

#### 8.1.4.1 函数原型应该总是对函数调用可见 [MISRA2012-RULE-17_3-2]

```c
/* file *.c */

void foo1(){}                     /* 非原型 */
void foo2(x, y);                  /* 非原型 */

void funCall(void){
  foo1();    /* 违规 - 没有原型的调用 */
  foo2(1,2); /* 违规 - 没有原型的调用 */
  foo3();    /* 违规 - 没有原型的调用 */
  foo4();    /* 违规 - 函数调用后声明原型 */
}

void foo2(x, y) int x; int y; {}

void foo4(void);
void foo4(void) {}
```

```c
/* file *.h */

void foo2(int x, int y); /* 添加显式类型 */
void foo3(void);         /* 添加原型到头文件 */
void foo4(void);         /* 移动原型到头文件 */

/* file *.c */
#include "*.h"

void foo1(void){}        /* 添加'void' */

void funCall(void){
  foo1();      /* OK */
  foo2(1,2);   /* OK */
  foo3();      /* OK */
  foo4();      /* OK */
}

void foo2(x, y) int x; int y; {} 
void foo3(void) {}
void foo4(void) {}
```

### 8.1.5 Rule-17.4

All exit paths from a function with non-void return type shall have an explicit return statement with an expression.

#### 8.1.5.1 非 void 返回类型的函数的所有退出路径应该有一个明确的包含表达式的返回语句 [MISRA2012-RULE-17_4-2]

```c
int foo1(int x)                             // 违规
{
    if(x == 0){
        if(x == 0){
            // 缺少 'return' 语句
        }else{
            return 0;
        }
    }else{
        return 0;
    }
}

int foo2(int x)                             // 违规
{
    switch(x)
    {
    case 0:
        return x + 1;
    case 1:
        return x + 2;
    case 2:
        return x + 3;
    // 缺少包含 'return' 的 'default' 语句
    }
}

int foo3(int x)
{
    // missing value in 'return'
    return;                                 // 违规
}

int foo4(int x)                             // 违规
{
    if (x > 10){
        return 0;
    }
    if (x <= 10){
        return 1;
    }
    // 无法到达的路径 - 规则不跟踪数据流
}

```

```c
int foo1(int x)                             // OK
{
    if(x == 0){
        if(x == 0){
            return x;
        }else{
            return 0;
        }
    }else{
        return 0;
    }
}

int foo2(int x)                             // OK
{
    switch(x)
    {
    case 0:
        return x + 1;
    case 1:
        return x + 2;
    case 2:
        return x + 3;
    default:
        return x;
    }
}

int foo3(int x)
{
    return 0;                               // OK
}

int foo4(int x)                             // OK 
{
    if (x > 10){
        return 0;
    }else{
        return 1;
    }
    // unreachable path
}
```

### 8.1.6 Rule-17.6

The declaration of an array parameter shall not contain the static keyword between the [ ].

#### 8.1.6.1 数组参数的声明不得在 [ ] 之间包含 'static' 关键字 [MISRA2012-RULE-17_6-2]

```c
typedef void foot(int a[static 10]);        /* 违规 */

void foo1(void (*fp1)(int a[static 10])) {  /* 违规 */
  void (*fp2)(int a[static 10]);            /* 违规 */
  fp1 = (void (*)(int a[static 10]))fp2;    /* 违规 */
}
```

### 8.1.7 Rule-19.1

An object shall not be assigned or copied to an overlapping object.

#### 8.1.7.1 不应该将结构体自身的一个成员变量赋给另一个成员变量 [MISRA2012-RULE-19_1_a-2]

```c
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U p;

    a.dValue  = a.lValue;     违规 
    p-dValue = p-iValue;    违规 
}
```

```c
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

void main( ) {
    union U a, b;
    union U p, q;
    a.dValue  = b.lValue;      /* OK */ 
    p-dValue = q-iValue;       /* OK */ 
}
```

#### 8.1.7.2 结构体的每个成员不应该赋值给自己的其他成员变量 [MISRA2012-RULE-19_1_b-2]

```c
#include <string.h>
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p;

    (void)memcpy( &a.dValue,  &a.lValue, 8 );    /* 违规 */
    (void)memcpy( &p->dValue, &p->iValue, 8 );   /* 违规 */
    return 0;
}
```

```c
#include <string.h>
union U {
    int         iValue; 
    long        lValue;
    double      dValue;
};

int main( ) {
    union U a, b;
    union U *p, *q;
    (void)memcpy( &a.dValue,  &b.lValue, 8 );     /* OK */
    (void)memcpy( &p->dValue, &q->iValue, 8 );    /* OK */
    return 0;
}
```

### 8.1.8 Rule-21.13

Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF.

**传递给 <ctype.h> 中的函数的任何值都应表示为无符号字符或值 EOF。**

`<ctype.h>` 是 C 语言标准库中的头文件，用于提供字符分类和转换函数。这些函数允许您对字符进行不同类型的操作，如判断字符是否是字母、数字、空格，以及将字符转换为大写或小写等。

以下是一些常见的 `<ctype.h>` 函数：

1. `isalpha(int c)`: 检查字符 `c` 是否是字母（a-zA-Z）。
2. `isdigit(int c)`: 检查字符 `c` 是否是数字（0-9）。
3. `isspace(int c)`: 检查字符 `c` 是否为空白字符（空格、制表符、换行符等）。
4. `islower(int c)`: 检查字符 `c` 是否是小写字母。
5. `isupper(int c)`: 检查字符 `c` 是否是大写字母。
6. `tolower(int c)`: 将字符 `c` 转换为小写字母（如果它是大写字母）。
7. `toupper(int c)`: 将字符 `c` 转换为大写字母（如果它是小写字母）。

**在使用`<ctype.h>`库中的函数时，传递给函数的参数应该满足以下两个条件之一**：

1. 必须能够表示为无符号字符（unsigned char）：这意味着传递给函数的值应该在无符号字符的范围内，通常是从0到255。`<ctype.h>`中的函数（如`isalpha()`、`isdigit()`等）通常接受int类型的参数，但传递的值应该在这个范围内。
2. 可以是`EOF`的值：`EOF`是在`<stdio.h>`库中定义的一个符号常量，用于表示文件结束或读取文件时的错误条件。在`<ctype.h>`函数的上下文中，它可以用于表示无效或数据结束的条件。

这个规则旨在确保`<ctype.h>`中的函数能够正确分类字符并处理任何错误或数据结束的条件。请注意，C++中也有类似的字符分类函数，但这个规则只适用于C语言。

因此，在使用`<ctype.h>`函数时，请确保传递给函数的参数满足这些条件，以确保程序的正确行为并遵守C语言标准。在C++中，您可以使用C++标准库中的字符分类函数，这些函数不受相同的参数限制。

### 8.1.9 Rule-21.17

Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters.

使用 <string.h> 中的字符串处理函数不会导致访问超出其指针参数引用的对象的范围。

### 8.1.10 Rule-21.18

The size_t argument passed to any function in <string.h> shall have an appropriate value.

传递给 <string.h> 中任何函数的size_t参数应具有适当的值。

### 8.1.11 Rule-21.19

The pointers returned by the Standard Library functions lovaleconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type.

标准库函数 lovaleconv、getenv、setlocale 或 strerror 返回的指针只能像它们具有指向 const 限定类型的指针一样使用。

### 8.1.12 Rule-21.20

The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale, or strerror shall not be used following a subsequent call to the same function.

标准库函数 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 strerror 返回的指针在后续调用同一函数后不得使用。

### 8.1.13 Rule-22.2

A block of memory shall only be freed if it was allocated by means of a Standard Library function.

#### 8.1.13.1 不得使用已经释放掉的资源 [MISRA2012-RULE-22_2_a-2]

```c
int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	delete[] buffer;
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}
```

```c
int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}
```

#### 8.1.13.2 不得使用无效的指针释放资源 [MISRA2012-RULE-22_2_b-2]

```c
#include <stdlib.h>

#define SIZE 100

int buffer[SIZE];

void process(int size)
{
	int* data = buffer;
	if (size > SIZE) {
		data = (int*)malloc(size*sizeof(int));
	}
	/* do something with the data buffer */
	free(data);
}
```

```c
#include <stdlib.h>

#define SIZE 100

int buffer[SIZE];

void process(int size)
{
    int* data = buffer;
    if (size > SIZE) {
        data = (int*)malloc(size*sizeof(int));
    }
	/* do something with the data buffer */
    if (size > SIZE) {
        free(data);
    }
}
```

### 8.1.14 Rule-22.4

There shall be no attempt to write to a stream which has been opened as read-only.

不得尝试写入已以只读方式打开的流。

### 8.1.15 Rule-22.5

A pointer to a FILE object shall not be dereferenced.

#### 8.1.15.1 指向文件对象的指针不能被解引用 [MISRA2012-RULE-22_5_a-2]

```c
#include<stdio.h>

void f1()
{
    FILE* ptrFile;

    *ptrFile;        /* 违规 */
    ptrFile[0];      /* 违规 */

    /* 下面的例子假设FILE * 用成员名
        '_file' 指定一个完整的类型*/
    ptrFile->_file;  /* 违规 */
}
```

#### 8.1.15.2指向文件对象的指针不能被库函数解除引用 [MISRA2012-RULE-22_5_b-2]

```c
#include <stdio.h>
#include <string.h>

void foo()
{
    FILE *fp;
    char *pch = "data";

    memcpy(fp, pch, 4); /* 违规 - 第一个参数的类型
                                       是 'FILE*' */
    memcpy(pch, fp, 4); /* 违规 -第二个参量的类型
                                       是 'FILE*' */
    memchr(fp, 'p', 4); /* 违规 - 第一个参量的类型
                                       是 'FILE*' */
}
```

### 8.1.16 Rule-22.6

The value of a pointer to a FILE shall not be used after the associated stream has been closed.

#### 8.1.16.1不得使用已经释放掉的资源 [MISRA2012-RULE-22_6-2]

```c
int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	delete[] buffer;
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}
```

```c
int compute(int* buffer, const int size)
{
	int result = 0;
	// perform computations
	return result;
}

void process(const int size)
{
	int* buffer = new int[size];
	int result = compute(buffer, size);
	delete[] buffer;
	// do something
}
```

## 8.2 必要的规则 MISRA Required Rules

### 8.2.1 Rule-1.1 Rule-1.3

**Rule-1.1:**The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation’s translation limits.

程序不应包含违反标准 C 语法和约束的内容，并且不应超出实现的翻译限制。

- 编写的程序必须符合C语言的语法规范。不能使用不合法或不被C标准接受的语法结构。这包括正确使用分号、括号、运算符等，并避免使用未定义的行为。如果程序包含语法错误，它将无法通过编译

- 程序不能超出C编译器或实现所规定的翻译限制。不同的C编译器可能对诸如函数参数数量、变量名长度、嵌套深度等方面有不同的限制。如果程序超出了这些限制，编译器可能无法处理它，或者程序可能在运行时出现问题。



**Rule-1.3:**There shall be no occurrence of undefined or critical unspecified behaviour.

不得发生未定义或严重的未指定行为。

1.  "Undefined behavior"（未定义行为）：在C语言中，有些操作的行为没有被明确定义。这意味着编译器和语言标准没有规定在这种情况下应该发生什么。因此，如果您的程序包含未定义行为，其行为可能是不确定的，可能会在不同的编译器或平台上产生不同的结果。这种情况下，程序可能会崩溃、产生奇怪的结果或者表现出其他不可预测的行为。
2.  "Critical unspecified behavior"（关键未指定行为）：这是一种更为严重的情况，它指的是在C语言标准中没有明确定义行为的操作，但在某些情况下可能导致安全风险或系统崩溃。这些情况通常需要特别小心处理，以确保程序的可靠性和安全性。

### 8.2.2 Rule-2.1

A project shall not contain unreachable code.

#### 8.2.2.1 "else" 语句块中不应存在执行不到的代码 [MISRA2012-RULE-2_1_a-3]

```c
void foo(int i){
    if(i == i) {
        // ...   
    } else {        // 违规
        i++;        // 不可到达代码
    }
  
    if(1) {
        // ...
    } else {        // 违规
        i++;        // 不可到达代码
    }
  
    if(0 <= 1) {
        // ...
    } else {        // 违规
        i++;        // 不可到达代码
    }
  
    if(0 <= 1 || i > 0) {
        // ...
    } else {        // 违规
        i++;        // 不可到达代码
    }
}
```

#### 8.2.2.2 在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码 [MISRA2012-RULE-2_1_b-3]

```c
void foo();
int myFunction(int i, int j)
{
    switch(i)
    {
        case 1:
            j = 5;
            break;    // Violation
            foo();
        case 2:
            j = 3;
            return j; // Violation
            foo();
    }
}
```

#### 8.2.2.3 在 "if/else/while/for" 语句块中不应存在执行不到的代码 [MISRA2012-RULE-2_1_c-3]

```c
void foo()
{
    int unreachable_code = 1;
    if(0)                         // 违规
    { 
        unreachable_code = 2; 
    }                 
}
```

#### 8.2.2.4 在 switch 语句中不应存在执行不到的代码 [MISRA2012-RULE-2_1_d-3]

```c
void foo( int i ) {
    switch (i) {    // 违规
        i = 0;
    case 1:
        i = 1;
        break;
    default:
        i = 2;
        break;
    }
}
```

#### 8.2.2.5 在 'for' 循环中不应存在执行不到的代码 [MISRA2012-RULE-2_1_e-3]

```c
void foo( int i, int j ) 
{
    for ( i = 0; i < 0; i++ )  // 违规
    {
      j = 1; 
    }
}
```

#### 8.2.2.6 在 'if' 或 'switch' 语句之后不应存在执行不到的代码 [MISRA2012-RULE-2_1_f-3]

```c
int foo1( int c ) {
    if ( c > 2 ) {    // Violation
        return 0;
    } else {
        return 1;
    }
    return c;         // 不可达代码
}

int foo2( int i ) {
    switch(i){        // 违规
    case 1:
        i++;
        return 0;
    case 2:
        i = i + 2;
        return 1;
    default:
        return 2;
    }
    return i;         // 不可达代码
}
```

#### 8.2.2.7 在 while/for/do...while 循环内的 "if" 或 "switch" 语句后不应存在执行不到的代码 [MISRA2012-RULE-2_1_g-3]

```c
int foo( int c ) {
    while ( c > 1 ) {
        if ( c > 2 ) {    // 违规
            continue;
        } else {
            break;
        }
        c++;              // 不可达代码
    }

    for (int i = 0; i > 1; i++ ) {
        switch(i){        // 违规
        case 1:
            i++;
            return i;
        case 2:
            i = i + 2;
            return i;
        default:
            return i;
        }
        c++;              // 不可达代码
    }
    return c;
}
```

### 8.2.3 Rule-2.3

There shall be no dead code.

#### 8.2.3.1 所有非 null 语句应该至少有一个执行或者导致控制流变化的附加作用 [MISRA2012-RULE-2_2_a-3]

```c
struct tagStruct {
    int _iField;
    char * _p;
};

int bar( );

void foo( ) {
    int i = 0;
    struct tagStruct s, *ps;
    /* Examples of incorrect code - no side effects: */
    i + 3;                    /* Violation - result not used */
    3;                        /* Violation - result not used */
    i;                        /* Violation - result not used */
    i + bar();                /* Violation - result not used */
    ps->_p + s._iField;       /* Violation - result not used */
    ps->_iField << s._iField; /* Violation - result not used */
    *(ps->_p);                /* Violation - result not used */
}
```

```c
struct tagStruct{
    int _iField;
    char * _p;
};

volatile struct tagStruct volStr;

int bar( );

void foo( ) {
    int i = 0;
    volatile int j = 0;
    struct tagStruct s, *ps;

    /* Examples of correct code - with side effects: */
    i = i + 3;               /* OK - assignment */
    i <<= 3;                 /* OK - assignment */
    bar();                   /* OK - function call */
    j;                       /* OK - volatile variable */
    volStr._p;               /* OK - volatile variable */
    if(ps->_iField){}        /* OK - cause control flow to change */

    ;                        /* OK - null statement */
    {}                       /* OK - empty block */
}
```

### 8.2.4 Rule-3.1

The character sequences /* and // shall not be used within a comment.

#### 8.2.4.1 禁止在 C 语言风格的注释中使用 /\* 字符序列 [MISRA2012-RULE-3_1_a-3]

```c
* 违规- 意外遗失注释结束符

<new page>
Perform_Safety_Critical_Code();

/* another comment closes the first comment so there are no parse errors */
```

```c
/* 检查代码并确定是否需要添加注释结束符。 */

/* 二选一，如果确定注释/代码是正确的，
   你需要移除/削减嵌入式注释标识：

<new page>
Perform_Safety_Critical_Code();

end of comment */

/* 建议的方法是使用注释 "添加注释" 来进行条件式编译: */
#if 0
Perform_Safety_Critical_Code();
#endif
```

#### 8.2.4.2 字符序列 // 不得被用于 C 语言风格的注释中 [MISRA2012-RULE-3_1_b-3]

```c
/* 违规 - 一些注释，结束注释标记意外的省略

<new page>
// 嵌入的注释建议注释掉的代码
Perform_Safety_Critical_Code();

/* 其它注释关闭第一个注释所有没有解析错误 */
```

```c
/* 检查代码并确定是否应该添加结束注释标记 */

/* 另外，如果确定注释/代码是正确的，你可以
   删除/分割嵌入的注释标记:

<new page>
去掉嵌入的注释标记
Perform_Safety_Critical_Code();

注释结束 */

/*建议 "注释掉" 代码的方式是使用条件编译: */
#if 0
some_code();
#endif
```

#### 8.2.4.3 字符序列 /\* 不得被用于 C++ 语言风格的注释中 [MISRA2012-RULE-3_1_c-3]

```c
// /* 违规 - 在 C++ 语言风格的注释中嵌入了 C 语言风格的注释 */
// some_code();

void foo ( int a, int b, int c )
{
  // 下面的代码执行 "a = b + c", 但是如果这里没有 "//" 注释
  // 结果将是 "a = b" :
  a = b // /* 违规 - 在 C++ 语言风格的注释中嵌入了 C 语言风格注释
  + c;
  // */
}
```

```c
// 使用条件编译来 "注释掉" 代码段
#if 0
/* OK */
some_code();
#endif

// 另外，如果你的编译器和代码标准允许
// 你也可以使用 C++ 语言风格的注释:
// // OK
// some_code();

void foo ( int a, int b, int c )
{
  a = b; /* OK - 没有嵌入的注释
  + c
  */
}
```

### 8.2.5 Rule-3.2

Line-splicing shall not be used in // comments.

#### 8.2.5.1 不得在 // 注释中使用行合并 [MISRA2012-RULE-3_2-3]

```c
// 这个例子表明很容易让一个注释以反斜杠
// 结束并且更改代码的意思:

// 反斜杠计数变量 backslashCount 没有被声明，
// 并且下一行导致违规:
// 计算反斜杠的数量: \
extern int backslashCount;

void foo(char *p)
{
  // 由于在注释中的反斜杠，总是执行 "return" !
  // 下一行导致违规:
  // 检查是否指针不是一个反斜杠字符: \
  if (p && *p == '\\')
  {
    return;
  }

  // 下面的代码将不会被执行
  // ...
}

// 如果这里在包含反斜杠的注释后面没有代码
// 规则将报告一个违规:
// 违规 \
```

```c
// 修改注释，例如删除结尾的反斜杠:
// 计算反斜杠数:
extern int backslashCount;

void foo(char *p)
{
  // 如果它不是最后一个字符你可以移动:
  // 检查是否指正不是一个反斜杠 '\' 字符:
  if (p && *p == '\\')
  {
    return;
  }
  //...
}

/* 只有  C++ 语言风格的注释才被检查，反斜杠不是一个违规: \
 */
```

### 8.2.6 Rule-4.1

Octal and hexadecimal escape sequences shall be terminated.

#### 8.2.6.1 八进制和十六进制转义序列将被终止 [MISRA2012-RULE-4_1-3]

```c
/* Examples of incorrectly terminated escape sequences: */
int c1 = '\141t';            /* 违规*/
const char *s1 = "\x41g";    /* 违规*/
s1 = "\01 \02";              /* 违规*/
```

```c
/* Examples of correctly terminated escape sequences: */
int c1 = '\141\t';           /* OK */
const char *s1 = "\x41" "g"; /* OK */
s1 = "\001 \002";            /* OK */
```

### 8.2.7 Rule-5.1

External identifiers shall be distinct.

在一个C程序中，所有外部标识符（external identifiers）必须是不同的，不能有重名的标识符：

-   **External identifiers**：外部标识符是在C程序中定义或声明的变量名、函数名、宏名等。这些标识符通常在不同的文件中定义，并且可能会在多个文件中使用。外部标识符的作用域通常超出了单个源代码文件。
-   **Distinct**："distinct" 意味着不同、独特或不重复。在这个上下文中，它要求不同的外部标识符不能有相同的名称。

这个规则的目的是确保在一个C程序中，不会出现同名的外部标识符，以避免混淆和命名冲突。如果有两个或多个外部标识符具有相同的名称，编译器无法区分它们，这可能导致编译错误或不确定的行为。

### 8.2.8 Rule-5.2

Identifiers declared in the same scope and name space shall be distinct.

在相同的作用域和名称空间（name space）中声明的标识符必须是不同的，不能有重名的标识符：

-   **Identifiers**：标识符是在编程中用于标识变量、函数、类型、宏等的名称。
-   **Declared**："declared" 意味着在程序中显式地定义或声明了标识符，这通常是通过变量声明、函数声明、类型定义等方式完成的。
-   **Same scope**："same scope" 意味着这个规则适用于相同的程序作用域。在C语言中，作用域指的是标识符的可见性范围，通常由代码块、函数、文件等定义。如果两个标识符在相同的作用域内声明，它们就被认为在相同的作用域中。
-   **Name space**："name space" 指的是标识符的命名空间，即标识符的名称池。在C语言中，不同的名称空间可以有不同的标识符，例如，全局名称空间和局部名称空间。

这个规则的目的是确保在相同的作用域和名称空间中，不会有相同名称的标识符，以避免命名冲突和混淆。如果在相同的作用域和名称空间中有两个或多个标识符具有相同的名称，编译器可能无法区分它们，这可能导致编译错误或不确定的行为。

### 8.2.9 Rule-5.3

An identifier declared in an inner scope shall not hide an identifier declared in an outer scope.

#### 8.2.9.1 在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符 [MISRA2012-RULE-5_3_a-3]

```c
int x = 10;
typedef enum {value1, value2} E;
void func();

void foo( ) {
    int x;             // 违规
    int value1;        // 违规
    void(*func)();     // 违规
}

struct S {int i;};

void foo2(){
    int S;   // 违规- 'S' 未隐藏结构体名称,
             // 会引起混乱
}
    
#ifdef __cplusplus
namespace N{
    struct NS {};
    void foo(int NS);  // 违规- 'NS' 未隐藏结构体名称，
                       // 会导致混乱
}
#endif
```

```c
int x = 10;
typedef enum {value1, value2} E;
void func();

void foo( ) {
    extern int x;      // OK - 'x' 引用的是全局的 'x'
    int foo_value1;    // OK - 名称已经更改
    void(*p_func)();   // OK - 名称已经更改
}

typedef struct {int i;}ST;

void foo2(){
    int S;         // OK - 这个结构体的名称已经更改
}

void foo1(){
    int var1;      // OK - 'var1' 没有隐藏全局变量
}

int var1;

#ifdef __cplusplus
namespace N1{
    struct NS {};
}

namespace N2{
    void foo(int NS);   // OK - 'NS' 声明在不同的命名空间
}
#endif
```

#### 8.2.9.2 在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符 [MISRA2012-RULE-5_3_b-3]

```c
void foo(int param) {
    int x;
    int var; 
    typedef enum {value1, value2} E;
    
    if (x > 0){
    	int param;     // 违规
    	int var = 10;  // 违规
    	int value1;    // 违规
    	enum E{value}; // 违规
    }
}
```

### 8.2.10 Rule-5.4

Macro identifiers shall be distinct.

#### 8.2.10.1 宏命名应与它的参数区分开来 [MISRA2012-RULE-5_4_a-3]

```c
#define MACRO1_01(MACRO1_01) MACRO1_01 + 1      /* 违规 */

/*      1234567890123456789012345678901********* Characters */
#define MACRO2_______________________0311( \
        MACRO2_______________________0311)      /* 违规 - reported in line above */

#define MACRO3____( \
        MACRO3_________________________X, \
        MACRO3_________________________Y)       /* 违规 - reported two lines above */
```

```c
#define MACRO1_01(MACRO1_02) MACRO1_02 + 1      /* OK - different name of
                                                        parameter */

#define MACRO2_______________________0311( \
        MACRO2_______________________0411)      /* OK - difference in first
                                                        31 characters */

#define MACRO3____( \
        MACRO3_________________________X, \
        MACRO3________________________XY)       /* OK */
```

#### 8.2.10.2 宏的名称应该有别于其他当前定义的宏的名称 [MISRA2012-RULE-5_4_b-3]

```c
#define macro1        10
#define macro1(X) X + 10                       /* 违规 */

#define macro2(param1_01) param1_01
#define param1_01 10                           /* 违规 */

#define param2_02 10
#define macro3(param2_02) param2_02            /* 违规 */

/*      123456789012345678901234567890123456789012345678901234567890123**** */
#define macro4_01____________________________________________________01X XX
#define macro4_01____________________________________________________01Y YY /* 违规 */
```

### 8.2.11 Rule-5.5

Identifiers shall be distinct from macro names.

#### 8.2.11.1 存在于预处理之前的宏命名应该与预处理之后的标识符区分开来  [MISRA2012-RULE-5_5-3]

```c
#define Sum(x, y) ( ( x ) + ( y ) )
int Sum;                                       /* 违规 */

#define ID1_macro_identifier_name__________________________________600X45(x) x
int ID1_macro_identifier_name__________________________________600X(X, Y); /*违规 */

#define ID2_struct DEF_STR
#undef ID2_struct
struct ID2_struct {};                          /* 违规 */

#ifdef MAC
  #define ID3_local LocalName
#endif

int ID3_local;                                 /* 违规 - reported if 'MAC' is not defined */
```

```c
#define Sum(x, y) ( ( x ) + ( y ) )
int SumL;                                       /* OK - different name */

#define ID1_macro_identifier_name__________________________________600XX(x) x
int ID1_macro_identifier_name__________________________________600YY(X, Y); /* OK */

#define ID2_struct DEF_STR
#undef ID2_struct
#define ID2_struct DEF_STR1

struct ID2_struct {};                           /* OK - macro expands to 'DEF_STR1' */
#define MAC 10

#ifdef MAC
  #define ID3_local LocalName
#endif

int ID3_local;                                  /* OK - macro expands to 'LocalName' */
```

### 8.2.12 Rule-5.6

A typedef name shall be a unique identifier.

#### 8.2.12.1 不能重用 typedef 名称 [MISRA2012-RULE-5_6_a-3]

```c
typedef int MyInt;
void foo() 
{
  double MyInt;  /* Violation */
}
```

#### 8.2.12.2 不能将 typedef 的名称重用在另一个 typedef 名称 [MISRA2012-RULE-5_6_b-3]

```c
typedef unsigned char uint8_t;

void foo()
{
   typedef signed char uint8_t; /* Violation */
}
```

### 8.2.13 Rule-5.7

A tag name shall be a unique identifier.

#### 8.2.13.1 标记的名称在程序中不得重用于其它目的 [MISRA2012-RULE-5_7_a-3]

```c
struct stag { int a; };      

void stag(void){}     // 违规  - 结构体名称重用为一个函数的名称
```

8.2.13.2标记的名称不得被重用于定义一个不同的标号 [MISRA2012-RULE-5_7_b-3]

```c
struct stag { int a; int b; };

void foo1()
{
    union stag  { int a; float b; }; // 违规
}

void foo2(void)
{
    struct stag { int a; };          // 违规
}

void foo3(void)
{
    struct stag { int a; int b; };   // 违规
}
```

### 8.2.14 Rule-5.8

Identifiers that define objects or functions with external linkage shall be unique.

具有外部链接（external linkage）的对象或函数的标识符必须是唯一的，不能重复定义。

让我来详细解释一下：

-   **Identifiers**：标识符是在编程中用于标识变量、函数、类型、宏等的名称。
-   **Objects or functions**：在C语言中，对象（objects）通常指的是变量，函数（functions）指的是函数定义。这个规则适用于定义这些变量或函数的标识符。
-   **External linkage**：外部链接是一个链接规范，用于指示标识符在不同文件之间的可见性和可访问性。具有外部链接的标识符可以在不同的源文件中共享和访问。这通常适用于全局变量和全局函数。

这个规则的目的是确保具有外部链接的对象或函数的标识符在整个程序中是唯一的，以避免冲突和错误。如果在不同的源文件中有相同名称的具有外部链接的对象或函数，这可能导致链接错误或运行时问题。

### 8.2.15 Rule-6.1

Bit-fields shall only be declared with an appropriate type.

#### 8.2.15.1 只能将位域定义为无符号的整型或有符号的整型 [MISRA2012-RULE-6_1-3]

```c
enum Enum { E1, E2};
struct Struct 
{
    unsigned char  f1:2;  /* 违规 */
    unsigned short f2:2;  /* 违规 */
    unsigned long  f3:2;  /* 违规 */
    enum Enum      f4:2;  /* 违规 */
    int            f5:2;  /* 违规 */
};
```

```c
struct Struct
{
    unsigned int f1:2;  /* OK */
    unsigned int f2:2;  /* OK */
    unsigned int f3:2;  /* OK */
    signed int   f4:2;  /* OK */
    signed int   f5:2;  /* OK */
};
```

### 8.2.16 Rule-6.2

Single-bit named bit fields shall not be of a signed type.

#### 8.2.16.1 由 signed 整型命名的位域应该有超过一位的长度 [MISRA2012-RULE-6_2-3]

```c
struct Bad
{
  int b1 : 1;            /* Violation - size too small */
  signed short b2 : 1;   /* Violation - size too small */
  signed char b3 : 1;    /* Violation - size too small */
};
```

```c
struct Good
{
  int b1 : 2;            /* OK - correct size */

  int : 0;               /* OK - unnamed */
  int : 1;               /* OK - unnamed */
  int : 2;               /* OK - unnamed */

  unsigned int b2 : 2;   /* OK - not a signed type */
  unsigned short b3 : 1; /* OK - not a signed type */
};
```

### 8.2.17 Rule-7.1

Octal constants shall not be used.

#### 8.2.17.1 八进制常量（除了0）不应该被使用 [MISRA2012-RULE-7_1-3]

```c
void foo() 
{
    int code1;
    int code2;

    code1 = 052;    /* 违规*/
    code2 = 071;    /* 违规*/
}
```

### 8.2.18 Rule-7.2

A ”u” or ”U” suffix shall be applied to all integer constants that are represented in an unsigned type.

#### 8.2.18.1 无符号类型的所有常量应该使用 'U' 后缀 [MISRA2012-RULE-7_2-3]

```c
long lVar = 2147483648;     /* 违规 */
long lVar = 2147483648U;    /* OK */
```

### 8.2.19 Rule-7.3

The lowercase character ”l” shall not be used in a literal suffix.

#### 8.2.19.1 使用大写 'L' 而非小写 'l' 来指定 long 类型 [MISRA2012-RULE-7_3-3]

```c
#define S1 11l    // 违规

void foo1(){
    long l;
    long long ll;
    unsigned long ul;

    ul = 11lu;    // 违规
    l  = 11l;     // 违规
    ll = 11111ll; // 违规
}
```

```c
#define S1 11L    // OK

void foo1(){
    long l;
    long long ll;
    unsigned long ul;

    ul = 11LU;    // OK
    l  = 11L;     // OK
    ll = 11111LL; // OK
}
```

### 8.2.20 Rule-7.4

A string literal shall not be assigned to an object unless the object’s type is ”pointer to const-qualified char”.

#### 8.2.20.1 不应该修改字符串字面量 [MISRA2012-RULE-7_4-3]

```c
void getcharptr(char* ptc);
void getchararr(char arr[]);

char* foo() {
  char* c1 = "Hello";    // 违规
  char* c2;
  int* p1;
  c2 = "Hello";          // 违规
  p1 = (int*)"Hello";    // 违规
  getcharptr("Hello");   // 违规
  getchararr("Hello");   // 违规

  return "Hello";        // 违规
}
```

```c
void getcharptr(const char* ptc);
void getchararr(const char arr[]);

const char* foo() {
  const char* c1 = "Hello"; // OK
  char arr1[] = "Hello";    // OK
  char arr2[6] = "Hello";   // OK
  const char* c2;
  c2 = "Hello";             // OK
  getcharptr("Hello");      // OK
  getchararr("Hello");      // OK

  return "Hello";           // OK
}
```

### 8.2.21 Rule-8.1

Types shall be explicitly specified.

编程中应该明确指定数据类型：

-   **Types**：类型指的是变量或表达式的数据类型，例如整数（int）、浮点数（float）、字符（char）等。在编程中，类型决定了变量可以存储的数据种类和范围。
-   **Explicitly specified**：明确指定意味着在声明或定义变量、函数参数、函数返回类型等时，应该明确指定所使用的数据类型。这可以通过使用关键字（如int、float、char等）或自定义的类型来实现。

8.2.21.1 声明或定义某个函数时，必须显式地规定其类型 [MISRA2012-RULE-8_1_a-3]

```c
foo1( void );        /* 违规 */
static foo2( void ); /* 违规 */
const foo3( void );  /* 违规 */

foo4(int i){         /* 违规 */
    return i;
}

foo5(int i){         /* 违规 */
    return;
}
```

```c
int foo1( void );        /* OK */
static int foo2( void ); /* OK */
const int foo3( void );  /* OK */

int foo4(int i){         /* OK */
    return i;
}

void foo5(int i){        /* OK */
    return;
}
```

### 8.2.22 Rule-8.2

Function types shall be in prototype form with named parameters.

#### 8.2.22.1 在函数原型声明中应该为所有参数提供标识符 [MISRA2012-RULE-8_2_a-3]

```c
void foo1(int);    /* 违规 */
```

```c
void foo1(int p);       /* OK */
```

#### 8.2.22.2 函数类型应该包含具体名称的参数 [MISRA2012-RULE-8_2_b-3]

```c
typedef void foot(int*);        /* 违规 */

void foo1(void (*fp1)(int)) {   /* 违规 */
  void (*fp2)(float);           /* 违规 */
  fp1 = (void (*)(int))fp2;     /* 违规 */
}
```

```c
typedef void foot(int* p1);       /* OK */

void foo1(void (*fp1)(int p)) {   /* OK */
  void (*fp2)(float f);           /* OK */
  fp1 = (void (*)(int p))fp2;     /* OK */
}
```

#### 8.2.22.3 函数类型应当为原型形式 [MISRA2012-RULE-8_2_c-3]

```c
int func1();   /* 违规 - 不是原型形式 */

int func2(n)   /* 违规 - K&R 风格的标识符和声明列表 */
int n;
{
    return n;
}

void (*fp1)(); /* 违规 - 不是为原型形式 */
```

```c
int func1(void);    /* OK - 原型指定 0 个参数 */

int func2(int n)    /* OK */
{
    return n;
}

void (*fp1)(void);  /* OK */
```

### 8.2.23 Rule-8.3

All declarations of an object or function shall use the same names and type qualifiers.

#### 8.2.23.1 如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的 [MISRA2012-RULE-8_3_a-3]

```c
int var1;    
short var1;      /* 违规*/

int var2;      
const int var2;  /* 违规*/

int* arr;  
int arr[5];      /* 违规*/

char foo1();              /* 违规*/
signed char foo1(); 

void foo2(signed int i);  /* 违规*/
void foo2(unsigned int i);
```

```c
short int var1;  /* OK */
short var1; 

const int var2;  /* OK */
const int var2;

int arr[];       /* OK */
int arr[5];

typedef char char_t;
char foo1();              /* OK */
char_t foo1();

void foo2(signed int i);  /* OK */
void foo2(int i);       

void foo3(int* ap);       /* OK */
void foo3(int ap[]);   
```

#### 8.2.23.2 禁止函数声明中使用的标识符与实际定义中的标识符不一致 [MISRA2012-RULE-8_3_b-3]

```c
void foo(int a, int b);
void foo(int x, int y ) {}  /* Violation */
```

### 8.2.24 Rule-8.4

A compatible declaration shall be visible when an object or function with external linkage is defined.

#### 8.2.24.1 当一个有外部联系的对象或函数被定义，则一个声明应该为可见的 [MISRA2012-RULE-8_4_a-3]

```c
/* file.c */
int i1;                   /* Violation - no declaration */
extern int ei1 = 1;       /* Violation - no declaration */
void foo1(int x){}        /* Violation - no declaration */
void foo2(int x){}        /* Violation - declaration after definition */
void foo2(int x);
```

```c
/* file.h */
extern int i1;
extern int ei1;
extern void foo1(int x);
extern void foo2(int x);

/* file.c */
#include "file.h"
int i1;                   /* OK */
int ei1 = 1;              /* OK */
void foo1(int x){}        /* OK */
void foo2(int x){}        /* OK */
```

### 8.2.25 Rule-8.6

An identifier with external linkage shall have exactly one external definition.

具有外部链接的标识符（通常是全局变量或函数）应该有且只有一个外部定义：

-   **Identifier with external linkage**：具有外部链接的标识符是指可以在不同源文件之间共享的标识符，通常是全局变量或函数。这些标识符的定义可以跨越多个源文件，并且它们在整个程序中可见。
-   **External definition**：外部定义是指标识符的实际实现或定义，通常包含在源文件中。一个标识符只能有一个外部定义，这是为了避免多个定义之间的冲突。

即两个文件不能同时定义同一个extern变量

### 8.2.26 Rule-8.8

The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage.

#### 8.2.26.1 带有内部链接的对象和函数应使用静态关键字进行定义和声明 [MISRA2012-RULE-8_8-3]

```c
static int x = 0;
extern int x;        /* 违规*/

static int foo1();
extern int foo1();   /* 违规*/

static void foo2();
void foo2() {}       /* 违规*/
```

### 8.2.27 Rule-8.10

An inline function shall be declared with the static storage class.

#### 8.2.27.1 内联函数应该声明为静态存储类 [MISRA2012-RULE-8_10-3]

```c
inline int fn1();                 /* 违规- 非静态内联函数 */
inline int fn1(){ return 0; }     /* 违规- 非静态内联函数 */
```

```c
static inline int fn1();             /* OK */
static inline int fn1(){ return 0; } /* OK */
```

### 8.2.28 Rule-8.12

Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique.

#### 8.2.28.1 在一个列举列表内，含蓄指定列举常数的值应该是唯一的 [MISRA2012-RULE-8_12-3]

```c
enum En1 {E11 = 1, E12, E13 = 2};             /* 违规 */
enum En2 {E21 = -2, E22, E23 = -1};           /*违规 */
enum En3 {E31, E32, E33 = E31};               /* 违规 */
```

```c
enum En1 {E11 = 1, E12 = 1, E13 = 2};         /* OK */
enum En2 {E21 = -2, E22 = -1, E23 = -1};      /* OK */
enum En3 {E31 = 0, E32, E33 = E31};           /* OK */
```

### 8.2.29 Rule-8.14

The restrict type qualifier shall not be used.

#### 8.2.29.1 不得使用严格的类型限定符 [MISRA2012-RULE-8_14-3]

```c
/* The code is compilable with compilers which support
   the 'restrict' type qualifier */
typedef int* restrict INT_R;     /* 违规*/
INT_R var1;                      /* OK - typedef 申明违规*/
void foo(void* restrict p){}     /* 违规*/

/* If 'restrict' is not a type qualifier (C90) this defines a variable */
  int restrict = 0;              /* 违规*/
```

### 8.2.30 Rule-9.2/Rule-9.3

The initializer for an aggregate or union shall be enclosed in braces.

#### 8.2.30.1在数组和结构体的非 0 初始化中，使用大括号进行标识和匹配 

```c
int y[3][2] = { 1, 2, 3, 4, 5, 6 }; // Violation

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, 2}; // Violation
```

```c
int y[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // OK

struct S {
    int i;
    struct T {
        int j;
    }t;
} s = {1, { 2 }}; // OK
```

### 8.2.31 Rule-9.4

An element of an object shall not be initialized more than once.

#### 8.2.31.1 一个对象的元素不应该被初始化多次

```c
int arr[3];
arr[0] = 1;
arr[1] = 2;
arr[0] = 3; // 错误：arr[0] 被多次初始化
```

### 8.2.32 Rule-9.5

Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly.

#### 8.2.32.1 当使用指定初始化器（designated initializers）来初始化数组对象时，必须明确指定数组的大小

```c
int arr[] = {1, 2, 3, 4, 5}; // 错误：没有明确指定数组的大小
```

### 8.2.33 Rule-10.1

Operands shall not be of an inappropriate essential type.

#### 8.2.33.1布尔类型的表达式应该始终用在需要布尔值操作数的位置 [MISRA2012-RULE-10_1_a-3]

```c
typedef enum {false, true} bool; /* 本质为布尔类型 */
void foo( void )
{
    bool b;
    int  i;
    char ch;

    if(!i);                  /* 违规 */
    !( b ? 1 : 2);           /* 违规 */

    if(i && ch);             /* 违规 */
    b = (i != b) || (i);     /* 违规 */
}
```

```c
#define FALSE 0
#define TRUE  1
typedef enum {false, true} bool; /* essentially Boolean type */

void foo( void )
{
    bool b;
    int  i;
    char ch;

    if(i == 0);                   /* OK */
    !( b ? TRUE : FALSE);         /* OK */

    if((i > 0) && (ch == 'a'));   /* OK */
    b = (i != b) || (i > 0);      /* OK */
}
```

#### 8.2.33.2 布尔类型的表达式不能用在需要数字值的位置 [MISRA2012-RULE-10_1_b-3]

```c
typedef enum {false, true} bool; /* essentially Boolean type */
void foo( int res )
{
    bool bb;
    int arr[2];
    int i1, i2;

    arr[bb];          /* Violation */
    res & (i1 > i2);  /* Violation */
    --bb;             /* Violation */
    false + 1;        /* Violation */
}
```

```c
typedef enum {false, true} bool; /* essentially Boolean type */
void foo( void )
{
    bool bb;
    int arr[2];
    int i1, i2;

    !bb;              /* OK */
    arr[1];           /* OK */
    --i1;             /* OK */
}
```

#### 8.2.33.3 字符类型操作数不应该用在需要数值类型操作数的位置 [MISRA2012-RULE-10_1_c-3]

```c
typedef char CHAR; /* essentially character type */
void foo( int res )
{
    CHAR ch;
    int arr[2];

    arr[ch];          /* 违规 */
    res & (ch + 1);   /* 违规 */
    ch >> 1u;         /* 违规 */
    ~'A';             /* 违规 */
}
```

```c
typedef unsigned char UCHAR; /* essentially unsigned type */
void foo( int res )
{
    UCHAR uch;
    int arr[2];

    arr[uch];          /* OK */
    res & (uch + 1);   /* OK */
    uch >> 1u;         /* OK */
    ~L'A';             /* OK */
}
```

#### 8.2.33.4 算术运算符的操作对象不应该是 enum 类型 [MISRA2012-RULE-10_1_d-3]

```c
typedef enum {EN1, EN2} TE1;   /* essentially enum type */
enum { EN11, EN12 } en1;       /* essentially enum type */

void foo( int res )
{
    TE1 te1;
    EN1 * 10;           /* 违规 */
    en1--;              /* 违规 */
    te1 >>= 1u;         /* 违规 */
    10 + EN11;          /* 违规 */
}
```

```c
typedef enum {EN1, EN2} TE1;   /* essentially enum type */
enum { EN11, EN12 };           /* EN11, EN22 有符号类型 */

void foo( int res )
{
    TE1 te1;
    if (EN1 == te1);    /* OK */
    10 + EN11;          /* OK */
}
```

#### 8.2.33.5 移位和位运算操作符的对象不应该是有符号类型或 enum 类型 [MISRA2012-RULE-10_1_e-3]

```c
typedef enum { EN1, EN2 } TE1;   /* essentially enum type */
void foo( void )
{
    signed char sc;
    signed int si;
    TE1 te1;

    te1 >> 10u;        /* 违规 */
    ~(sc + 1);         /* 违规 */
    si | 10;           /* 违规 x 2 */
}
```

```c
void foo( void )
{
    unsigned char uc;
    unsigned int ui;
    unsigned int *pui;

    /* 正确代码示例 */
    ui >> 10u;        /* OK */
    ~(uc + 1u);       /* OK */
    *pui | 10u;       /* OK */
}
```

#### 8.2.33.6 移位运算符的右边操作对象不能是signed 或 enum类型 [MISRA2012-RULE-10_1_f-3]

```c
signed int ret_int(void);

void foo ( void )
{
    signed char c1, c2;
    int i1;
    
    i1 << c1;                /* Violation */
    c1 >> c2;                /* Violation */
    i1 <<= (c1 + c2);        /* Violation */
 
    i1 >>= ret_int();        /* Violation */
}
```

```c
signed int ret_int(void);

void foo ( void )
{
    signed char c1;
    unsigned char c2;
    int i1;

    i1 << (unsigned char)c1;            /* OK */
    c1 >> c2;                           /* OK */
    i1 <<= (unsigned char)(c1 + c2);    /* OK */
    i1 >>= (unsigned int)ret_int();     /* OK */
}
```

#### 8.2.33.7 unsigned类型的操作数不能用作一元的 '-' 运算符的操作对象 [MISRA2012-RULE-10_1_g-3]

```c
unsigned int ret_uint(void);

void foo ( void )
{
    unsigned char uc1, uc2;
    unsigned int ui1;
    -ui1;            /* 违规 */
    -(uc1 + uc2);    /* 违规 */
    -10u;            /* 违规 */
    -ret_uint();     /* 违规 */
}
```

```c
unsigned int ret_uint(void);

void foo ( void )
{
    unsigned char uc1, uc2;
    unsigned int ui1;
    -(int)ui1;                    /* OK */
    -(signed char)(uc1 + uc2);    /* OK */
    -10;                          /* OK */
    -(signed int)ret_uint();      /* OK */
}
```

### 8.2.34 Rule-10.2

Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations.

8.2.34.1不能在加减运算中误用字符型表达式 [MISRA2012-RULE-10_2-3]

```c
typedef enum {EN1, EN2} TE1;   /* essentially enum type */
enum { EN11, EN12 } en1;       /* essentially enum type */

void foo()
{
    char ch;
    TE1 te1;
    float f;
    ch   + EN1;         /* Violation - "character"     + "enum constant" */
    ch   -= f;          /* Violation - "character"     - "floating" */
    EN12 - ch;          /* Violation - "enum constant" - "character" */
    en1  += ch;         /* Violation - "enum"          + "character" */
    1    - ch;          /* Violation - "signed"        - "character" */
    te1  -= '1';        /* Violation - "enum"          - "character" */
}
```

```c
enum { EN11, EN12 };    /* EN11, EN22 have essentially signed type */

void foo( int res )
{
    char ch;
    int  i;
    unsigned char uch;
    float f;
    EN11 + ch;          /* OK - "signed"    + "character" */
    1u   + ch;          /* OK - "unsigned"  + "character" */
    ch   - EN12;        /* OK - "character" - signed */
    ch   -= i;          /* OK - "character" - int */
    ch   -= 'a';        /* OK - "character" - "character" */
    uch  += ch;         /* OK - "unsigned character" + "character" */
}
```

### 8.2.35 Rule-10.3

The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category.

#### 8.2.35.1 表达式的值不能赋给一个表数范围更小的基本类型 [MISRA2012-RULE-10_3_a-3]

```c
void short_int(unsigned int i){ };

signed char foo(int i)
{
    signed char sch = 128;      /* 违规 */
    sch = i;                    /* 违规 */
    short_int(1ULL);            /*违规 */
    switch(sch)
    {
        case 1000:  ;           /* 违规 */
        case 2L:  ;             /* 违规 */
    }
    return i;                   /* 违规 */
}
```

```c
void short_int(unsigned int i){ };

signed char foo(int i)
{
    signed short sch = 128;     /* OK */
    sch = (signed char)i;       /* OK */
    short_int(1U);              /* OK */
    switch(sch)
    {
        case 1000:  ;           /* OK */
    }
    return (signed char)i;      /* OK */
}
```

#### 8.2.35.2 表达式的值不能赋给一个基本类型不同的对象 [MISRA2012-RULE-10_3_b-3]

```c
void short_int( int i){ };

double foo(int i)
{
    char ch = 10;             /* 违规- 字符型和无符号型 */
    i = 20.0;                 /* 违规 - 有符号型和浮点型 */
    short_int(1UL);           /* 违规 - 有符号型和无符号型 */
    switch(i)
    {
        case 'a':             /* 违规 - 字符型和有符号型 */
            i = 'a' + 1;      /* 违规 - 字符型和有符号型 */
        case 3u:              /* 违规 - 有符号型和无符号型 */
            i = 'a' - 1;      /* 违规 - 字符型和有符号型 */
    }
    return i;                 /* 违规 - 有符号型和浮点型 */
}
```

### 8.2.36 Rule-10.4

Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category.

#### 8.2.36.1 算术转化操作符的两个操作对象必须具有相同的基本类型 [MISRA2012-RULE-10_4_a-3]

```c
typedef enum {EN1, EN2} TE1;        /*  enum 类型 */
enum EN{ EN11, EN12 };              /*  enum 类型 */
enum {E1, E2};                      /*  signed 类型 */
typedef unsigned short      ushort; /*  unsigned 类型*/
typedef enum {false, true}  bool;   /*  Boolean 类型 */

void foo()
{
    TE1 te1;
    enum EN e1;
    float fl;
    ushort us;
    bool b;
    long l;

    us + 1;          /* 违规 - "unsigned" + "signed" */
    10 - '1';        /* 违规 - "signed"   - "character" */
    1u + E2;         /* 违规 - "unsigned" + "signed" */
    fl += 1;         /* 违规 - "floating" += "signed" */
    b * te1;         /* 违规 - "boolean"  * "enum" */
    us / 'a';        /* 违规 - "unsigned" / "character" */
    b & 2;           /* 违规 - "boolean"  & "signed" */
    l - 2u;          /* 违规 - "signed"   - "unsigned" */
    if(b == E1);     /* 违规 - "boolean"  == "enum" */
    if(EN2 < EN11);  /* 违规 - "enum<TE1>" < "enum<EN>" */
}
```

#### 8.2.36.2 三元运算符的第二和第三个操作对象必须是同样的基本类型 [MISRA2012-RULE-10_4_b-3]

```c
signed int ret_int(void);

void foo ( float f )
{
    char ch;
    unsigned int ui;

    (ui > 0) ? 'E' : 10;        /* 违规 - "character" and "signed" */
    (ui > 0) ? ui : ret_int();  /* 违规 - "unsigned" and "signed" */
    (ui > 0) ? f : ch;          /* 违规 - "floating" and "character" */
}
```

```c
signed int ret_int(void);

void foo ( float f )
{
    signed char sc;
    unsigned int ui;

    (ui > 0) ? ui : 10u;        /* OK */
    (ui > 0) ? sc : ret_int();  /* OK */
    (ui > 0) ? f : 10.0;        /* OK */
}
```

### 8.2.37 Rule-10.6

The value of a composite expression shall not be assigned to an object with wider essential type.

#### 8.2.37.1 复合表达式的值不应该赋值给宽数据类型的一个对象 [MISRA2012-RULE-10_6-3]

```c
void goo(unsigned int u32p);

double foo1( float f32p ) {
    unsigned char u8a, u8b;
    unsigned int u32a = u8a + u8b;               /* 违规 */
    u32a = u8a + 10u;;                           /* 违规 */
    goo(u8a >> 4);                               /* 违规 */
    return f32p * 10.1f;                         /* 违规 */
}
```

```c
void goo(unsigned int u32p);

double foo1( float f32p ) {
    unsigned char u8a, u8b;
    unsigned int u32a = (unsigned int)u8a + u8b;               /* OK */
    u32a = (unsigned int)(u8a + 10u);                          /* OK */
    goo((unsigned int)u8a >> 4);                               /* OK */
    return f32p * 10.1;                                        /* OK */
}
```

### 8.2.38 Rule-10.7

If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type.

8.2.38.1 如果复合表达式作为一个操作数用于通常的算术运算并与比它位数宽的操作数进行运算时将报告违规 [MISRA2012-RULE-10_7_a-3]

```c
void foo1( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u16b + u16a + u32b;                            /* 违规 */
    u32a = u32b * (u16a + u16b);                          /* 违规*/
    u32a += u16b >> 4;                                    /* 违规*/
}

void foo2(int x) {
    float f32a, f32b;
    double f64a, f64b;

    f64a = f32a + f32b + 10.0;                            /* 违规 */
    f64a = f64a + ((x > 0) ? f32a + f32b : 0.1f);         /* 违规 */
}
```

```c
void foo1ok( ) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = u16b + (u16a + u32b);                          /* OK */
    u32a = u32b * ((unsigned int)u16a + u16b);            /* OK */
    u32a += (unsigned int)u16b >> 4;                      /* OK */
}

void foo2ok(int x) {
    float f32a, f32b;
    double f64a, f64b;

    f64a = f32a + f32b + 10.0f;                           /* OK */
    f64a = f64a + ((x > 0) ? (double)f32a + f32b : 0.1f); /* OK */
}
```

8.2.38.2 如果复合表达式被用于条件运算符的操作数，那么其他操作数不应该有更宽的类型 [MISRA2012-RULE-10_7_b-3]

```c
void foo1(int x) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = (x > 0) ? u16b + u16a : u32b;                      /* 违规 */
    u32a = (x > 0) ? u32b : (u16a + u16b);                    /* 违规 */
}

void foo2(int x) {
    float f32a, f32b;
    double f64a, f64b;

    f64a = (x > 0) ? f32a + f32b : 10.0;                      /* 违规 */
    f64a = (x > 0) ? f64a : ((x > 0) ? f32a + f32b : 0.1f);   /* 违规 */
}
```

```c
void foo1ok(int x) {
    unsigned short u16a,u16b;
    unsigned int u32a, u32b;

    u32a = (x > 0) ? (unsigned int) u16b + u16a : u32b;              /* OK */
    u32a = (x > 0) ? u32b : ((unsigned int)u16a + u16b);             /* OK */
}

void foo2ok(int x) {
    float f32a, f32b;
    double f64a, f64b;

    f64a = (x > 0) ? (double)f32a + f32b : 10.0;                     /* OK */
    f64a = (x > 0) ? f64a : ((x > 0) ? (double)f32a + f32b : 0.1f);  /* OK */
}
```

### 8.2.39 Rule-10.8

The value of a composite expression shall not be cast to a different essential type category or a wider essential type.

#### 8.2.39.1 复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型 [MISRA2012-RULE-10_8-3]

```c
void foo(int s32a, int s32b, unsigned short u16a, unsigned short u16b)
{
    /* 传递到一个不同的基本类型类别 ("signed" to "unsigned") */
    (unsigned short) (s32a + s32b);         /* Violation */
    
    /* Cast to wider essential type (16 bit to 32 bit ")*/
    (unsigned int) (u16a + u16b);           /* Violation */
}
```

```c
void foo(unsigned int u32a, unsigned int u32b, int s32a)
{
     /*传递到相同基本类型类别 Cast to same essential type category (unsigned) to a narrower type */
    (unsigned short) (u32a + u32b);    

    /* s32a is not a composite expression */
    (unsigned short) s32a;    
}
```

### 8.2.40 Rule-11.1

Conversions shall not be performed between a pointer to a function and any other type.

#### 8.2.40.1 不应该在指向函数的指针和其它类型直接执行转换 [MISRA2012-RULE-11_1_a-3]

```c
typedef void (*FP)(int n);
void f (FP);

void foo (void* vptr)
{
    FP fp;
    int i;
    int* ptr;
    struct S* sp;
  
    /* Examples of incorrect code */  
    i = fp;                 /* Violation */
    ptr = (int*)fp;         /* Violation */
    f(sp);                  /* Violation */
    fp = (FP)vptr;          /* Violation */
}
```

```c
#define NULL (void*)0

typedef void (*FP)(int n);
void f (int n);

void foo (void* vptr)
{
    FP fp1;
    void (*fp2)(int n);  
    int (*fp3)();  

    /* Examples of correct code and exceptions */  
    fp1 = fp2;              /* OK - compatible types */
    fp1 = f;                /* OK - compatible types */
    fp1 = 0;                /* OK - exception */
    fp1 = NULL;             /* OK - exception */
    (void)( fp3( ) );       /* OK - exception */
}
```

#### 8.2.40.2 不应该在不兼容的指向函数指针上直接执行转换 [MISRA2012-RULE-11_1_b-3]

```c
typedef void (*FP1)(int n);
typedef void (*FP2)(short n);
typedef int* (*FP3)(int n);
typedef void (*FP4)(const int n);
typedef void (*FP5)(int n, ...);

/* Examples of incorrect code */ 
void f (FP4 fp4);

FP5 foo (void* vptr)
{
    FP1 fp1;
    FP2 fp2;
    FP3 fp3;
    FP4 fp4 = fp1;       /* Violation */
  
    fp1 = fp2;           /* Violation */
    fp3 = (FP3)fp2;      /* Violation */
    f( fp1 );            /* Violation */
    
    return fp2;          /* Violation */
}
```

```c
typedef short SHORT;
typedef void (*FP1)(short n);
typedef void (*FP2)(short int n);
typedef void (*FP3)(signed short n);
typedef void (*FP4)(SHORT n);
typedef void (*FP5)(int* n);
typedef void (*FP6)(int a[]);

/* Examples of correct code */ 
void f (FP4 fp4);

FP3 foo (void* vptr)
{
    FP1 fp1;
    FP2 fp2;
    FP3 fp3;
    FP4 fp4 = fp1;       /* OK - compatible types */
    FP5 fp5;
    FP6 fp6 = fp5;       /* OK - compatible types */
  
    fp1 = fp2;           /* OK - compatible types */
    fp3 = (FP3)fp2;      /* OK - compatible types */
    f( fp1 );            /* OK - compatible types */
    
    return fp2;          /* OK - compatible types */
}
```

### 8.2.41 Rule-11.2

Conversions shall not be performed between a pointer to an incomplete type and any other type.

#### 8.2.41.1 不应该在指向不完全类型和其它类型的指针直接执行转换 [MISRA2012-RULE-11_2-3]

```c
typedef struct S1* ST1;
typedef struct S2 ST2;

/* 不正确的例子代码 */ 
void f (struct S3* sp3);

ST2* foo (void* vptr)
{
    ST1 sp1;
    ST2* sp2;
    int* ptr = sp1;      /* Violation - implicit conversion from a pointer
                            to an incomplete struct to a pointer to int type 
                            in an initialization */
  
    sp1 = (ST1)sp2;      /* Violation - explicit cast is not allowed */
    f( ptr );            /* Violation - implicit conversion from a pointer
                            to int type to a pointer an incomplete struct type
                            in a function call */
    
    return vptr;         /* Violation - implicit conversion from a pointer
                            to void type to a pointer to an incomplete struct
                            type in a function return */
}
```

```c
#include <stddef.h>

typedef struct S1* ST1;

/* 正确的代码和异常的例子 */ 
struct S3* f ( void );

ST1 foo (void* vptr)
{
    ST1 sp1;
    struct S1* sp2 = NULL; /* OK - A null pointer constant may be converted
                              into a pointer to an incomplete type */
    sp1 = sp2;             /* OK - the same types */
    sp1 = (ST1)sp2;        /* OK - the same types */
    (void)f( );            /* OK - A pointer to an incomplete type may
                              be converted into void. */
    return sp1;            /* OK - the same types */
}
```

### 8.2.42 Rule-11.3

A cast shall not be performed between a pointer to object type and a pointer to a different object type.

#### 8.2.24.1 不应再指向对象类型的指针和指向另一个对象类型的指针之间执行传递 [MISRA2012-RULE-11_3-3]

```c
void func()
{
    unsigned char* uc;
    unsigned int*  ui;
    const int* const* cpci;
    
    (unsigned int*)uc;       /* Violation */
    (signed int*)ui;         /* Violation */
    (int* const*)cpci;       /* Violation */
}
```

```c
void func()
{
    unsigned char* uc;
    signed int* si;
    const int* const* cpci;
    
    (char*)uc;               /* OK - Exception */
    (int*)si;                /* OK - the same types */
    (const int**)cpci;       /* OK - the rule is applied to unqualified types */
    (int)si;                 /* OK - the cast is not to the pointer type */
}
```

### 8.2.43 Rule-11.6

A cast shall not be performed between pointer to void and an arithmetic type.

#### 8.2.43.1 不应在指向空的指针和运算类型直接执行传递 [MISRA2012-RULE-11_6-3]

```c
void* getVoid ( void );
void f2 ( void* );
enum E { E1, E2 } e;

char foo1 ( void* vptr )
{
  signed int si = ( int ) vptr; /* Violation */
  ( short ) vptr;               /* Violation */
  return ( char ) getVoid ( );  /* Violation */
}

void* foo2 ( unsigned int ui )
{
  void* vptr = ( void* ) 0x001; /* Violation */
  ( void* ) ui;                 /* Violation */
  f2 ( ( void* ) ui );          /* Violation */
  return ( void* ) e;           /* Violation */
}
```

```c
typedef void* VOID_PTR;

VOID_PTR foo ( int* int_p )
{
  /* Exception: null pointer: */
  void* vptr = ( void* ) 0;       /* OK */

  /* Not reported: conversions not involving arithmetic type */
  int_p = ( int* ) vptr;          /* OK */

  /* Not reported: implicit conversion */
  return 1;                       /* OK */
}
```

### 8.2.44 Rule-11.7

A cast shall not be performed between pointer to object and a non-integer arithmetic type.

#### 8.2.44.1 不应该在指向对象的指针和费整数运算类型之间执行传递 [MISRA2012-RULE-11_7-3]

```c
struct S {
  int x;
};
struct S * sp;  /* pointer to "object type" */

int *ptr_obj;   /* pointer to "object type" */

char c;         /* variable with "non-integer arithmetic type" */

enum E { EV };
enum { VV } e2; /* variable with "non-integer arithmetic types" */

void foo1 ( void )
{
  (char) sp;          /* Violation */
  (enum E) ptr_obj;   /* Violation */

  (struct S *) c;     /* Violation */
  (int *) EV;         /* Violation */
  (char *) e2;        /* Violation */

  (float *) (c < 0);  /* Violation */
}
```

```c
struct S;
struct S * ptr_to_incomplete;
void* ptr_to_void;

signed char sc;
enum { EV };

enum E { E1 };
struct R { int x; };

void foo1 ( void )
{
  (char) ptr_to_incomplete; /* Not reported - pointer to incomplete type */
  (enum E) ptr_to_void;     /* Not reported - pointer to void */

  (struct R *) sc;          /* Not reported - not plain char */
  (int *) EV;               /* Not reported - unnamed enum */
}
```

### 8.2.45 Rule-11.8

A cast shall not remove any const or volatile qualification from the type pointed to by a pointer.

#### 8.2.45.1 禁止强制类型转换操作删除以指针指定的 const 或 volatile 限制 [MISRA2012-RULE-11_8-3]

```c
typedef unsigned short uint16_t;
void foo( ) 
{
    uint16_t *pi, **ppi;
    uint16_t * const * pcpi;  /* pointer to const pointer */
    const uint16_t * * ppci;  /* pointer to pointer to const */
    const uint16_t * pci;     /* pointer to const */
    volatile uint16_t * pvi;  /* pointer to volatile */

    pi = (uint16_t *)pci;     /* Violation */
    pi = (uint16_t *)pvi;     /* Violation */
    ppi = (uint16_t * *)pcpi; /* Violation */
    ppi = (uint16_t * *)ppci; /* Violation */
}

/* Removing const or volatile qualifiers from the pointer is allowed */
void foo2()
{
    uint16_t *pi;
    const uint16_t *cpi;
    uint16_t * const pic = 0;           /* const pointer to a type */
    const uint16_t * volatile cpiv;     /* volatile pointer to a type */
  
    pi = (uint16_t *)pic;           /* OK - const removed from the pointer,
                                       not the pointed type */
    cpi = (const uint16_t *)cpiv;   /* OK - volatile removed from the pointer,
                                       not the pointed type */
}
```

### 8.2.46 Rule-11.9

The macro NULL shall be the only permitted form of integer null pointer constant.

#### 8.2.46.1 字面量零 (0) 不得用作空指针常量 (null-pointer-constant) [MISRA2012-RULE-11_9_a-3]

```c
#define MY_NULL 0
#define CALL_FUNC(x) ( getptr( ( x ) ) )
void getptr ( int * );

int* foo ( int* p1 )
{
  int* v1 = 0;                      /* 违规 */
  if ( 0 == v1 );                   /* 违规 */
  CALL_FUNC( 0 );                   /* 违规 */

  /* 字面量 0 被用作 "?:" 的第二个和第三个操作数，其它的操作数
   * 有指针类型 */
  p1 ? 0 : p1;                      /* 违规 */

  return 0;                         /* 违规 */
}
```

```c
#define NULL 0
#define CALL_FUNC(x) ( getptr( ( x ) ))
void getptr ( int* );

int* foo1 ( int* p1 )
{
  int* v1 = NULL;                   /* Compliant */
  if ( ( void* ) 0 == v1 );         /* Compliant */
  CALL_FUNC( NULL );                /* Compliant */
  p1 ? ( void* ) 0 : p1;            /* Compliant */
  return NULL;                      /* Compliant */
}
```

#### 8.2.46.2 用 NULL 来代替字面零 (0) 作为空指针常量 [MISRA2012-RULE-11_9_b-3]

```c
#define MY_NULL 0
#define CALL_FUNC(x) (getptr( (x) ))
void getptr(int*);

int* foop1(int* p1)
{
    int* v1 = 0;  /* 违规*/
    p1 = MY_NULL; /* 违规*/
    if(0 == v1);  /* 违规*/
    CALL_FUNC(0); /* 违规*/

    /* Literal 0 is used as 2nd or 3rd operand of "?:" and the other operand
     * has pointer type */
    p1 ? 0 : p1;  /* 违规*/

    return 0;     /* 违规*/
}
```

```c
#define NULL 0
#define CALL_FUNC(x) (getptr( (x) ))
void getptr(int*);

int* foop1(int* p1)
{
    int* v1 = NULL;     /* OK */
    p1 = NULL;          /* OK */
    if((void*)0 == v1); /* OK */
    CALL_FUNC(NULL);    /* OK */
    p1 ? (void*)0 : p1; /* OK */
    return NULL;        /* OK */
}
```

### 8.2.47 Rule-12.2

The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand.

#### 8.2.47.1 移位运算符的右边操作数的位宽应该介于零和一个小于左操作数的原始类型的位宽之间 [MISRA2012-RULE-12_2-3]

```c
typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef signed int      int32_t;
void foo( uint16_t p, int32_t i ) 
{
   uint8_t u8a;

   u8a = (uint8_t) (u8a << 9); /* 违规 */
   u8a = (uint8_t) (1u << 9);  /* 违规 - '1u' 的潜在/基本类型 
                                  是无符号字符类型(unsigned char) */
   u8a = (uint8_t) (u8a << p); /* 违规 */
   u8a = (uint8_t) (u8a >> i); /* 违规 */
}
```

```c
typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef signed int      int32_t;
void foo( uint16_t p, int32_t i ) 
{
   uint8_t u8a;
   uint16_t u16a;
 
   u16a = (uint16_t) ((uint16_t) u8a << 9); /* OK */
   u16a = (uint16_t) ((uint16_t) 1u << 9);  /* OK */

   if (p <= 8) {
       u8a = (uint8_t) (u8a << p); /* OK - 需要检查 'p'
                                      的上限 */
   }
   
   if (i >= 0 && i <= 8) {
       u8a = (uint8_t) (u8a << i); /* OK - 'i' 两边的限制
                                      都需要检查 */
   }

   u8a = (uint8_t) (u8a << 4);     /* OK - 在范围内的常量值 */
}
```

### 8.2.48 Rule-13.1

Initializer lists shall not contain persistent side-effects.

#### 8.2.48.1 初始化器列表不应该包含持久的副作用 [MISRA2012-RULE-13_1_a-3]

```c
typedef struct S {
    int ms1;
    int ms2;
} TS;

void foo1( ) {
    int i;
    int j;
    volatile int v;
    int a1[4] = {i, j, i, j++};   // 违规
    TS ts1 = {v, 0};              // 违规
    (int [3]){i = 1, 0, 0};       // 违规
}
```

```c
typedef struct S {
    int ms1;
    int ms2;
} TS;

void foo1( ) {
    int i;
    int j;
    int a[2] = {i + j, i - j};                 // OK
}
```

### 8.2.49 Rule-13.2

The value of an expression and its persistent side-effects shall be the same under all permitted evaluation orders.

#### 8.2.49.1 表达式的值应该在任何标准允许的赋值顺序下是一样的 [MISRA2012-RULE-13_2_a-3]

```c
void foo1(int i) 
{
    int x;
    int b[10];

    x = b[i] + i++; // Violation - This will give different results depending
                    // on whether b[i] is evaluated before i++ or vice versa.
}

int foo_m(int);
void foo2(){
    int x;
    int y;
    int* p;

    y = ++x + x;        // Violation
    y = x + foo_m(x++); // Violation
    y = x + (x = 1);    // Violation
    *p = *p++;          // Violation
}
```

```c
void foo1(int i) 
{
    int x;
    int b[10];

    x = b[i] + i;   // OK - The problem could be avoided by putting
    i++;            // the increment operation in a separate statement.
}

int foo_m(int);
void foo2(){
    int x, y;
    int* p;
	
    ++x;
    y = x + x;        // OK
    y = x + foo_m(x); // OK
    *(p+1) = *p;      // OK
    p++;

    y = ++x && x;   // OK - the order of evaluation is defined
    y = x || x++;   // OK - the order of evaluation is defined
    y = x++, x;     // OK - the order of evaluation is defined
    y = y++;        // OK - this rule does not report violation if a variable
                    // is modified more than once in statement.
    y = y + 1;      // OK - variable 'y' is used to determine its stored value 
}
```

#### 8.2.49.2 不要编写需要依赖函数参数赋值顺序的代码 [MISRA2012-RULE-13_2_b-3]

```c
void Transmogrify(int,int);
int Bump(int& x) {return ++x;}
void foo()
{
    int count = 5;
    Transmogrify(Bump(count),Bump(count)); // 违规
    Transmogrify(count++,count);           // 违规
}
```

```c
void Transmogrify(int,int);
int Bump(int& x) {return ++x;}
void foo()
{
    int count = 5;
    int temp1 = Bump(count);
    Transmogrify(temp1,Bump(count)); // OK
    Transmogrify(count,count);       // OK
    count++;
}
```

#### 8.2.49.3 不要编写依赖于函数标示符和函数参数估值顺序的代码 [MISRA2012-RULE-13_2_c-3]

```c
struct S {
    void (*fp)( struct S* );
};

void foo(struct S* sp) {
    sp->fp(sp++);           // Violation
    (++sp)->fp(sp);         // Violation
}
```

```c
struct S {
    void (*fp)( struct S* );
};

void foo(struct S* sp) {
    sp->fp(sp);           // OK - The problem could be avoided by putting
    sp++;                 // the increment operation in a separate statement.
}
```

#### 8.2.49.4 对涉及一个函数调用的表达式不要编写依赖表达式求值顺序的代码 [MISRA2012-RULE-13_2_d-3]

```c
int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    i = foo(&j) + bar(j);    // 违规
}
```

```c
int foo(int* ptr)
{
    (*ptr)++;
    return 0;
}
int bar(int local_param)
{
    return local_param;
}

void foo_t(int i, int j)
{
    int temp = foo(&j);
    i = temp + bar(j);    // OK
}
```

#### 8.2.49.5 一个对象在序列点之间应该使其存储值在表达式的计算中最多可修改一次 [MISRA2012-RULE-13_2_e-3]

```c
void foo1(){
    int i, j;
    i = ++i + 1;   // Violation
    j = ++i + i--; // Violation
}
```

```c
void foo1(){
    int i, j;
    ++i;       // OK
    i += 1;    // OK
    ++i;       // OK
    j = i + i; // OK
    i--;       // OK
}

int foo_int(int);
void foo_m(int p){
    int i;

    i = 0, i++;       // OK - there is a sequence point between modifications
    p = foo_int(p++); // OK - there is a sequence point between modifications
    if(i++ && i--);   // OK - there is a sequence point between modifications
}
```

#### 8.2.49.6 禁止在表达式中多次使用 volatile 类型的变量 [MISRA2012-RULE-13_2_f-3]

```c
void foo( )
{
    volatile int x;
    int y;
    y = x * x;  // 违规
}
```

```c
void foo( )
{
    volatile int x;
    int y;
    y = x;      // OK
    y = y * y;
}
```

#### 8.2.49.7 不要写依赖于求值函数调用顺序的代码 [MISRA2012-RULE-13_2_g-3]

```c
int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global() + use_global();  // 违规
}
```

```c
int global;

int modify_global()
{
    global++;
    return global;
}
int use_global()
{
    return global;
}

void expr1()
{
    int a = modify_global();
    a += use_global();           // OK
}
```

### 8.2.50 Rule-13.5

The right hand operand of a logical && or || operator shall not contain persistent side effects.

#### 8.2.50.1 逻辑 && 或者 || 运算符的右操作数不应该包含副作用 [MISRA2012-RULE-13_5-3]

```c
void foo1( ) {
    int i;
    int j;
    if ((j == i) || (0 == i++)) ;                // 违规
    if ((j == i) || (0 == (i = j))) ;            // 违规
}

int global_object;
int side_effect_function1(){
    global_object = 0;
    //...
    return global_object;
}

int side_effect_function2(int* ptr){
    *ptr = 0;
    //...
    return *ptr;
}

int side_effect_function3(int i){
    int* ptr = &i;
    *ptr = 0;
    //...
    return *ptr;
}

int side_effect_function4(int i){
    volatile int vi;
    i = vi;
    //...
    return i;
}

void foo2( ) {
    int i;
    int j;
    if ((j == i) && side_effect_function1()) ;   // 违规
    
    if ((j == i) && side_effect_function2(&i)) ; // 违规
    
    // 修改解引用的指针将始终被认为是一个持久的
    // 副作用，即使例如这个指针指向一个局部变量
    if ((j == i) && side_effect_function3(i)) ;  // 违规
    
    if ((j == i) && side_effect_function4(i)) ;  // 违规
}
```

```c
void foo1( ) {
    int i;
    int j;
    if ((j == i) || (0 == i))   // OK
    	i++;
}

int global_object;
int side_effect_function(){
    global_object = 0;
    //...
    return 1;
}

void foo2( ) {
    int i;
    int j;
    
    if (j == i){
    	if(side_effect_function()); // OK
    }
}
```

### 8.2.51 Rule-14.1

A loop counter shall not have essentially floating type.

#### 8.2.51.1 'for' 循环中的循环计数器不能是浮点类型 [MISRA2012-RULE-14_1_a-3]

```c
void canModifyObject(double* pf);

void foo()
{
    float vf;
    for (vf = 0.0f; vf < 1.0f; vf += 0.01f);       /* 违规 */

    double vd = 10.0f;
    /* 'vd' 可能在函数 'canModifyObject'中被更改 */
    for(; vd > 1.0f; canModifyObject( &vd )) { }   /* 违规 */

    float farr[] = { 0.1f, 0.2f, 0.3f };
    for(farr[0] = 0; farr[0] < 1; farr[0]++);      /* 违规 */
}
```

```c
void foo()
{
    float f = 0.0f; 
    int counter;
    for (counter = 0;  counter < 128; counter++)    /* OK */
    {
        f = (float)counter + f;
    }
}
```

#### 8.2.51.2 在 'while' 和 'do-while' 循环中的循环计数器不能是浮点类型 [MISRA2012-RULE-14_1_b-3]

```c
void canModifyObject(float* pf);

void foo()
{
    float count1 = 0.0f;
    while( count1 < 1.0f )     /* 违规 */
    {
        count1++;
    }

    while( count1 < 5.0f )     /* 违规 */
    {
        /* 'count1' can be modified in the function 'canModifyObject' */
        canModifyObject( &count1 );
    }

    double count2 = 10.0;
    do                         /* 违规 */
    {
        count2 -= 5.0;
    } while( count2 > 1.0 );
}
```

```c
void foo()
{
    float f = 0.0f;
    int counter = 0;
    while( counter < 10 )            /* OK */
    {
        f = (float)counter + f;
        counter++;
    }

    f = 0.0f;
    counter = 0;
    do                               /* OK */
    {
        f = (float)counter + f;
        counter++;
    } while( counter < 10 );
}
```

### 8.2.52 Rule-14.2

A for loop shall be well-formed.

#### 8.2.52.1 'for'循环中只能有一个循环计数器，并且不能在'for'循环体中被修改 [MISRA2012-RULE-14_2_a-3]

```c
int incr(int* ptr){
  ++(*ptr);
  return *ptr;
}

void foo()
{
    int i, j;
    int a[3];

    for(i = 0; i < 10; ++i)     /* 违规  */
        i -= 1;                 /* 循环计数器 'i' 再循环体内被修改 */

    for(; a[i] < 10; incr(&i))  /* 违规 */
        ++i;                    /* 循环计数器 'i' 再循环体内被修改 */
    for(; i < j; ++i, --j){}    /* 违规 - 'i'和 'j' 都是循环计数器 */
}
```

```c
int incr(int* ptr){
  ++(*ptr);
  return *ptr;
}

void foo()
{
    int i, j;
    int a[3];

    for(i = 0; i < 10; ++i)      /* OK  */
        j -= i;

    for(; a[i] < 10; incr(&i)){  /* OK */
        j = i;
        j++;
    }
    for(; i < 10; ++i){          /* OK */
      for(; j < 10; --j){}       /* OK */
    }
}
```

#### 8.2.52.2 'for' 语句循环条件中的第一个类目必须符合语法规范 [MISRA2012-RULE-14_2_b-3]

```c
void foo()
{
    int i;
    int j;
    int a[3];

    for(i == 0; i < 10; ++i) {        /* 违规 */
    /* Improper expression is used in the first clause of a 'for' statement */
    }

    for(int k; a[k] < 10; k += 1) {   /* 违规 */
    /* 循环计数器 'k' 在'for'语句第一个类目中定义
     * 但没有初始化 (C99 and C++ code) */
    }

    for(i = j++; i < 10; ++i) {       /* 违规 */
    /* 'for' 语句中的第一个类目除了对循环计数器的修改之外 
     * 还包含了永久的不良影响 */
    }

    for(i = 0, j = 1; i < 10 && j < 20; ++i, ++j) {       /* Violation */
    /*  'for' 语句的第一个类目的赋值对象
     * 不止一个 */
    }
}
```

```c
void foo()
{
    int i;
    int j;
    int a[3];

    for(i = 0; i < 10; ++i) {           /* OK */
    }

    for(int k = 0; a[k] < 10; k += 1) { /* OK */
    }

    i = 0;
    for(; i < 10; ++i) {                /* OK - first clause could be empty */
    }
}
```

#### 8.2.52.3 'for'循环的第二个类目必须符合语法规范 [MISRA2012-RULE-14_2_c-3]

```c
void foo()
{
    int i, j;

    /* The second clause of a 'for' statement contains an object
     * that is modified inside the loop body: 'j' */
    for (i = 0; i < j; i++) {                                  /* Violation */
        j += 2;
    }

    /* The second clause of a 'for' statement contains
     * an expression that has a persistent side effect */
    for(i = 0; i = 10; i++) { }                                /* Violation */

    /* The second clause of a 'for' statement
     * does not contain a loop counter */
    for(i = 0; i < 10; ) { }                                   /* Violation */
}
```

```c
typedef enum {false, true} Bool;

void foo()
{
    int i, j;
    Bool flag = false;

    for(i = 0; i < 10; i++) { }            /* OK */

    for (i = 0; i < 10 && flag; i++) {     /* OK */
        flag = true;
    }
}
```

#### 8.2.52.4 'for' 语句的第三个类目必须符合语法 [MISRA2012-RULE-14_2_d-3]

```c
void foo()
{
    int i;
    int j;

    for(i = 0, j = 100; i < 50 && j > 50; i++, j--){ /* 违规 */
        /* 第三个类目包含逗号 */
    }

    for (i = 0; i < 1024; i += j ) {                 /* 违规 */
        j = 2;  /* 第三个类目包含在循环体内修改的对象 */
    }

    for(i = 0; i < 10; i = j++) {                    /* 违规 */
        /* 第三个类目中包含有永久不良影响的 */
        /* 的表达式r */
    }

    for(i = 0; i < 10; i + 5) {                      /*违规*/
        /* 第三个类目中含有修改循环计数器之外 */
        /* 的表达式 */
    }
}
```

```c
void foo()
{
    int i;
    int j;

    for (i = 0; i < 1024; i += j ) {                /* OK */
        /* 'j'没有在循环体内部修改 */
    }

    for (i = 100;  i < 1024; i++ ) {                /* OK */
    }
}
```

### 8.2.53 Rule-14.3

Controlling expressions shall not be invariant.

#### 8.2.53.1 不允许其结果是不变的布尔运算 [MISRA2012-RULE-14_3_a-3]

```c
void myFunction(int a)
{
    if((a <= 1)&&(a >= 2)); // Violation 
    if((a < 1)&&(a > 2));   // Violation 
    if((a >= 2)&&(a <= 1)); // Violation 
    if((a > 2)&&(a < 1));   // Violation 
}
```

```c
void myFunction(int a)
{
    if((a <= 5)&&(a >= 2)); // OK
    if((a < 5)&&(a > 2));   // OK
    if((a >= 2)&&(a <= 5)); // OK
    if((a > 2)&&(a < 5));   // OK
}
```

#### 8.2.53.2 避免始终判断为相同值的条件 [MISRA2012-RULE-14_3_zc-3]

```c
#include "stdio.h"

void processHexValue(char*);

static void checkRange(char* cur)
{
	if ((*cur < '0') || (*cur > '9')) {
		printf("Error: only digits are permitted");
		return;
	}
	// obviously dead code
	if ((*cur >= 'a') && (*cur <= 'f')) {
		processHexValue(cur);
	}
}
```

```c
#include "stdio.h"

static void checkRange(char* cur)
{
	if ((*cur < '0') || (*cur > '9')) {
		printf("Error: only decimal digits are permitted");
		return;
	}
}
```

#### 8.2.53.3 避免具有无法到达分支的开关语句 [MISRA2012-RULE-14_3_zd-3]

```c
#include "stdio.h"

enum Figures {
	SPHERE,
	CIRCLE,
	CUBE,
	SQUARE,
	HIMESPHERE
};

static void guessFigure(int round, int volumetric)
{
    int figure;
    if (round && volumetric) {
        figure = SPHERE;
    } else if (round && !volumetric) {
        figure = CIRCLE; 
    } else if (!round && volumetric) {
        figure = CUBE;
    } else {
    	figure = SQUARE;
    }
    
    switch (figure) {
		case SQUARE:
			printf("This is a sphere");
			break;
        case HIMESPHERE:
			printf("This is a hemispere");//无法到达
            break;
        case CIRCLE:
			printf("This is a circle");
            break;
        case CUBE:
			printf("This is a cube");
            break;
		default:
			printf("This is a square");
			break;
	}
}
```

### 8.2.54 Rule-14.4

The controlling expression of an if-statement and the controlling expression of an iteration-statement shall have essentially Boolean type.

#### 8.2.54.1 测试一个值是否为零应该是显式的，除非操作数实际上是布尔值 [MISRA2012-RULE-14_4-3]

```c
int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo()) {}	// 违规
  if (y) {}     // 违规
}
```

```c
int goo()
{
    return 1;
}

void foo( int x, int y )
{
  if (goo() != 0) {}	// OK
  if (y != 0) {}        // OK
}
```

### 8.2.55 Rule-15.2

The goto statement shall jump to a label declared later in the same function.

#### 8.2.55.1 goto 语句应该跳转到随后在同一个函数中声明的标签 [MISRA2012-RULE-15_2-3]

```c
void foo(int j)
{
    L1:
    ++j;
    goto L1; // 违规 - 向回跳转
    ++j;
}
```

```c
void foo(int j)
{
    ++j;
    goto L1; // OK -  向前跳转
    ++j;
    L1:
}
```

### 8.2.56 Rule-15.3

Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement.

#### 8.2.56.1 任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包围 goto 语句的模块中 [MISRA2012-RULE-15_3-3]

```c
int f1 ( void )
{
    int j;
    goto L1;  /* Violation - jump into nested block */

    for ( j = 0; j < 10 ; ++j )
    {
        /* ... */
    L1:
        return j;
    }
}
void f2 ( int k )
{
  if ( k > 0 )
  {
    goto L; /* Violation: target block does not enclose current block */
  }
  if ( k < 0 )
  {
    L:
    ++k;
  }
}
```

```c
int f1 ( void )
{
    int j = 0;
	
    for ( j = 0; j < 10 ; ++j )
    {
        goto L1; /* OK - jump into outside block */
        /* ... */
    }

    L1:
    return j;
}
void f2 ( int k )
{
  while ( k < 0 )
  {
    int j = k * 2;
    while ( j < 10 )
    {
      if ( k > 0 )
      {
        goto L; /* OK: target block encloses current block (indirectly) */
      }
    }
    L:
    ++k;
  }
}
```

### 8.2.57 Rule-15.6

The body of an iteration-statement or a selection-statement shall be a compound-statement.

#### 8.2.57.1 'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句 [MISRA2012-RULE-15_6_a-3]

```c
void foo( int x ) {
    int i;

    switch(i)             // Violation
    ;

    for (i=0; i< 10; i++) // Violation 
        foo( x );
    while (1)             // Violation
        foo( x );

    do                    // Violation
    foo( x );
    while(1);
}
```

```c
void foo( int x ) {
    int i;

    switch(i)             // OK
    {
    }

    for (i=0; i< 10; i++) // OK
            {foo( x );}
    while (1)             // OK
        {foo( x );}

    do                    // OK
        {foo( x );}
    while(1);
}
```

#### 8.2.57.2 在 'if' 和 'else' 之后应该紧跟着复合语句 [MISRA2012-RULE-15_6_b-3]

```c
void foo( int x, int y )
{
    int i, j;
    if(x > 0)      // Violation
        x = i;
    else if(y > 0) // Violation
        y = i;
    else
        y = j;     // Violation
        x = j;
}
```

```c
void foo( int x, int y )
{
    int i, j;
    if(x > 0)      // OK
    {
        x = i;
    }
    else if(y > 0) // OK
    {
        y = i;
    }
    else
    {
        y = j;     // OK
        x = j;
    }
}
```

### 8.2.58 Rule-15.7

All if ... else if constructs shall be terminated with an else statement.

#### 8.2.58.1 所有的 'if...else-if' 结构中应该由 'else' 分支结束 [MISRA2012-RULE-15_7-3]

```c
void foo(int a)
{
    if(a > 0)
    {
    }
    else if (a > 10)   // Violation
    {
    }
}
```

```c
void foo(int a)
{
    if(a > 0)
    {
    }
    else if (a > 10)   // OK
    {
    }
    else
    {
        // comment or action
    }
}
```

### 8.2.59 Rule-16.1

All switch statements shall be well-formed.

#### 8.2.59.1 switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码 [MISRA2012-RULE-16_1_a-3]

```c
void foo(int a, int b)
{
    switch(a)
    {
        int c = 0;  /* 违规 */
    case 1:
        break;
    case 2:
        break;
   
    default:
        break;
    }
    
    switch(b)
      a = 3;        /* 违规 */
}
```

```c
void foo(int a,int b)
{
    int c = 0;    /* OK */
    switch(a)
    {
    case 1:
        break;
    case 2:
        break;
   
    default:
        break;
    }
    
    a = 3;        /* OK */
}
```

#### 8.2.59.2 只能当最临近的复合语句是 switch 语句体时才能使用 switch 标签 [MISRA2012-RULE-16_1_b-3]

```c
void foo( int a, int b ) {
    switch(a) {
    case 1:
        {
            case 6:     /* 违规 */
            ;
            default:    /* 违规 */
            break;
        }
        break;
    case 2:
        if (b == 1) {
             case 3:      /* 违规 */
             break;
        }
        break;
    }
}
```

#### 8.2.59.3 无条件的 break 语句应该作为每一个非空 case 子句的结束 [MISRA2012-RULE-16_1_c-3]

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i > 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}
```

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :         // 通过
            i = 4;
            i++;
            break;
        case 1 :         // 通过
            i = 7;
            if (i > 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // 通过
            {
                i = 3;
                break;
            }
        case 3 :         // OK
            {
                i = 3;
            }
            break;
        case 4 :         // 通过 - 空case语句
        default:         // 通过
            i = 8;
            break;
    }
}
```

#### 8.2.59.4 无条件的 break 语句应作为作为每一个非空 default 条件的结束 [MISRA2012-RULE-16_1_d-3]

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :
            i = 4;
            break;
	case 1:
            i = 5;
            break;
        default:       // Violation
            i = 8;
    }
}
```

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :
            i = 4;
            break;
	case 1:
            i = 5;
            break;
        default:       // OK
            i = 8;
            break;
    }
}
```

#### 8.2.59.5 始终为 switch 语句提供一个 default 分支 [MISRA2012-RULE-16_1_e-3]

```c
enum E {
  E1, E2
};
void foo ( int x, enum E e )
{
  switch ( x )  /* Violation: missing 'default' */
  {
    case 0:
      // ...
      break;
  }
  switch ( e )  /* Violation: missing 'default' */
  {
    case E1:
      // ...
      break;
    case E2:
      // ...
      break;
  }
}
```

```c
enum E {
  E1, E2
};
void foo ( int x, enum E e )
{
  switch ( x )  /* OK: 'default' present */
  {
    case 0:
      // ...
      break;
    default:
      // ...
      break;
  }
  switch ( e )  /* OK: 'default' present */
  {
    case E1:
      // ...
      break;
    case E2:
      // ...
      break;
    default:
      // ...
      break;
  }
}
```

#### 8.2.59.6 在 'default' 标签的结束 'break' 之前应该有一个语句或者一个注释 [MISRA2012-RULE-16_1_f-3]

```c
void fn1 ( int i )
{
  switch ( i )
  {
    /* No comment nor statement before terminating 'break' */
    default:
      break;    /* 违规*/
  }
}
```

```c
/* Examples of code which is compliant with this rule: */
void fn1 ( int i )
{
  switch ( i )
  {
    /* There is a statement before terminating break: */
    default:
      ++i;
      break;    /* OK */
  }
  switch ( i )
  {
    /* There is a comment before terminating break: */
    default:
      /* A comment which explains why the default can be empty */
      break;    /* OK */
  }
  switch ( i )
  {
    /* 'case' is not checked: */
    case 1:
      break;
    default:
      ++i;
      break;
  }
  switch ( i )
  {
    /* 没有 'break'终结符时不进行违规报告 */
    default:
      return;
  }
}
```

#### 8.2.59.7 如果存在一个 'default' 标签，应该作为 switch 语句的第一个或最后一个 switch 标签 [MISRA2012-RULE-16_1_g-3]

```c
/* Examples of incorrect 'default' placements: */
void foo ( int i )
{
  switch ( i )
  {
    case 0:
    default:              /* 违规: 'default'不是第一个或最后一个标签  */
      i = 8;
      break;
    case 1:
      i = 7;
      break;
  }
  switch ( i )
  {
    case 0:
      i = 8;
      break;
    default:              /* 违规: 'default' 不是最后一个或第一个标签  */
      i = 10;
      break;
    case 1:
      i = 7;
      break;
  }
  switch ( i )
  {
    case 0:
      i = 8;
      break;
    default:              /* 违规: 'default' 不是最后一个或第一个标签  */
    case 1:
      i = 7;
      break;
  }
}
```

```c
/* Examples of correct 'default' placements: */
void foo ( int i )
{
  switch ( i )
  {
    default:              /* OK: 'default' 是第一个标签 */
    case 0:
      i = 8;
      break;
    case 1:
      i = 7;
      break;
  }
  switch ( i )
  {
    default:              /* OK: 'default'是第一个标签*/
      i = 10;
      break;
    case 0:
      i = 8;
      break;
    case 1:
      i = 7;
      break;
  }
  switch ( i )
  {
    case 0:
      i = 8;
      break;
    case 1:
    default:              /* OK: 'default' 是最后一个标签*/
      i = 7;
      break;
  }
  switch ( i )
  {
    case 0:
      i = 8;
      break;
    case 1:
      i = 7;
      break;
    default:              /* OK: 'default' 是最后一个标签*/
      i = 10;
      break;
  }
}

/*缺少'default'不是该规则的违规情况: */
void bar ( int i )
{
  switch ( i )
  {
    case 0:
      i = 8;
      break;
    case 1:
      i = 7;
      break;
  }
}
```

#### 8.2.59.8 每一个 switch 语句应该含有至少两个 switch 子句 [MISRA2012-RULE-16_1_h-3]

```c
void example ( int i )
{
  switch ( i )                        /* 违规 */
  {
    case 0:
    case 1:
      /* A switch-clause */
      i = i + 1;
      break;
    default:
      /* 没有表达语句不能被计算为一个switch子句 */
  }

  switch ( i )                        /* 违规 */
  {
    case 1:
    default:
      /* A switch-clause */
      i = i + 1;
      break;
  }
}
```

```c
void repair ( int i )
{
  /* 第一个switch被重写成一个 'if' */
  if ( ( i == 0 ) || ( i == 1 ) )
  {
    i = i + 1;
  }

  /* 第二个是switch被修改为含有两个switch子句 */
  switch ( i )                        /* Compliant */
  {
    case 1:
      /* A switch-clause */
      break;
    default:
      /* A switch-clause */
      i = i + 1;
      break;
  }
}
```

#### 8.2.59.9 switch 表达式不应该出现一个实际为布尔的值 [MISRA2012-RULE-16_1_i-3]

```c
void foo(int i)
{
    switch(i == 0)           /* 违规 */
    {
        case 0 :
            /* ... */  
            break;
        default:
            /* ... */ 
            break;
    }
}
```

```c
void foo(int i)
{
    switch(i)                /* OK */
    {
        case 0 :
            /* ... */  
            break;
        default:
            /* ... */ 
            break;
    }
  
    if(i == 0)               /* OK */
    {
        /* ... */ 
    }
    else
    {
        /* ... */ 
    }
}
```

### 8.2.60 Rule-16.2

A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.

#### 8.2.60.1 只能当最临近的复合语句是 switch 语句体时才能使用 switch 标签 [MISRA2012-RULE-16_2-3]

```c
void foo( int a, int b ) {
    switch(a) {
    case 1:
        {
            case 6:     /* 违规 */
            ;
            default:    /* 违规 */
            break;
        }
        break;
    case 2:
        if (b == 1) {
             case 3:      /* 违规 */
             break;
        }
        break;
    }
}
```

### 8.2.61 Rule-16.3

An unconditional break statement shall terminate every switch-clause.

#### 8.2.61.1 无条件的 break 语句应该作为每一个非空 case 子句的结束 [MISRA2012-RULE-16_3_a-3]

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :         // 违规
            i = 4;
            break;
            i++;
        case 1 :         // 违规
            i = 7;
            if (i > 0)
            {
                i = 5;
                break;
            }
        case 2 :         // 违规
            {
                i = 3;
            }
        default:         // 违规
            i = 8;
    }
}
```

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :         // 通过
            i = 4;
            i++;
            break;
        case 1 :         // 通过
            i = 7;
            if (i > 0)
            {
                i = 5;
                break;
            }
            break;
        case 2 :         // 通过
            {
                i = 3;
                break;
            }
        case 3 :         // OK
            {
                i = 3;
            }
            break;
        case 4 :         // 通过 - 空case语句
        default:         // 通过
            i = 8;
            break;
    }
}
```

#### 8.2.61.2 无条件的 break 语句应作为作为每一个非空 default 条件的结束 [MISRA2012-RULE-16_3_b-3]

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :
            i = 4;
            break;
	case 1:
            i = 5;
            break;
        default:       // Violation
            i = 8;
    }
}
```

```c
void foo( int i )
{
    switch( i )
    {
        case 0 :
            i = 4;
            break;
	case 1:
            i = 5;
            break;
        default:       // OK
            i = 8;
            break;
    }
}
```

### 8.2.62 Rule-16.4

Every switch statement shall have a default label.

#### 8.2.62.1 始终为 switch 语句提供一个 default 分支 [MISRA2012-RULE-16_4_a-3]

#### 8.2.62.2 在 'default' 标签的结束 'break' 之前应该有一个语句或者一个注释 [MISRA2012-RULE-16_4_b-3]

```c
void fn1 ( int i )
{
  switch ( i )
  {
    /* No comment nor statement before terminating 'break' */
    default:
      break;    /* 违规*/
  }
}
```

```c
void fn1 ( int i )
{
  switch ( i )
  {
    /* No comment nor statement before terminating 'break' */
    default:
          /* 注释 */
      break;    /* OK */
  }
}
```

### 8.2.63 Rule-16.5

A default label shall appear as either the first or the last switch label of a switch statement.

#### 8.2.63.1 如果存在一个 'default' 标签，应该作为 switch 语句的第一个或最后一个 switch 标签 [MISRA2012-RULE-16_5-3]

### 8.2.64 Rule-16.6

Every switch statement shall have at least two switch-clauses.

#### 8.2.64.1 如果存在一个 'default' 标签，应该作为 switch 语句的第一个或最后一个 switch 标签 [MISRA2012-RULE-16_5-3]

```C
void example ( int i )
{
  switch ( i )                        /* 违规 */
  {
    case 0:
    case 1:
      /* A switch-clause */
      i = i + 1;
      break;
    default:
      /* 没有表达语句不能被计算为一个switch子句 */
  }

  switch ( i )                        /* 违规 */
  {
    case 1:
    default:
      /* A switch-clause */
      i = i + 1;
      break;
  }
}
```

### 8.2.65 Rule-16.7

A switch-expression shall not have essentially Boolean type.

#### 8.2.65.1 switch 表达式不应该出现一个实际为布尔的值 [MISRA2012-RULE-16_7_a-3]

```C
void foo(int i)
{
    switch(i == 0)           /* 违规 */
    {
        case 0 :
            /* ... */  
            break;
        default:
            /* ... */ 
            break;
    }
}
```

### 8.2.66 Rule-17.1

The features of <stdarg.h> shall not be used.

#### 8.2.66.1 不得使用 va_list, va_arg, va_start, va_end, va_copy 标识符 [MISRA2012-RULE-17_1_a-3]

```c
#include <stdarg.h>

void foo1(int i, ...){
  va_list ap;          /* 违规 */
  
  va_start(ap, i);     /* 违规 */
  
  va_arg(ap, int);     /* 违规 */
  
  va_end(ap);          /* 违规 */
}
```

### 8.2.67 Rule-17.2

Functions shall not call themselves, either directly or indirectly.

#### 8.2.67.1 函数不应该直接或者间接地调用自己 [MISRA2012-RULE-17_2-3]

```c
void foo1(){
    foo1();     /* Violation - direct recursion */
}

void foo2();
void foo3();

void foo2(){
    foo3();     /* Violation - indirect recursion */
}

void foo3(){
    foo2();     /* 违规-间接递归 */
}
```

### 8.2.68 Rule-17.7

The value returned by a function having non-void return type shall be used.

#### 8.2.68.1 应该使用具有非 void 返回类型的函数返回值 [MISRA2012-RULE-17_7_a-3]

```c
int foo ();
void bar ()
{
  foo ( );                /* 违规*/
  foo ( ) + foo ( );      /* 违规*/
  foo ( ) && foo ( );     /* 违规*/
}
```

```c
int foo ();
void goo ( int i );
int bar ( int i )
{
  i = foo ( );                  /* OK - assigned */
  goo ( foo ( ) + foo ( ) );    /* OK - passed to a function */
  if ( foo ( ) )                /* OK - used in selection statement */
  {
    ( void ) foo ( );           /* OK - cast to void */
  }
  return foo ( ) && foo ( );    /* OK - returned */
}
```

#### 8.2.68.2 不得使用一个非 void 返回类型函数返回的值 [MISRA2012-RULE-17_7_b-3]

```c
int foo ();
void bar ( int i )
{
  foo ( ), i;                    /* 违规*/
  ( foo ( ) + foo ( ) ), i;      /* 违规*/
  ( foo ( ) && foo ( ) ), i;     /* 违规*/
}
```

```c
int foo ();
void goo ( int i );
int bar ( int i )
{
  ( i = foo ( ) ), i;                  /* OK - assigned */
  ( goo ( foo ( ) + foo ( ) ) ), i;    /* OK - passed to a function */
  ( ( void ) foo ( ), i );             /* OK - cast to void */
}
```

### 8.2.69 Rule-18.1

A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand.

通过对指针操作进行算术运算得到的指针应该指向与原指针操作数相同的数组元素。这个规则的目的是确保指针算术操作不会导致越界访问其他数组的元素

```c
int arr[] = {1, 2, 3, 4, 5};
int *ptr = &arr[0];
int *newPtr = ptr + 6;/* 违规 地址越界 */
```

### 8.2.70 Rule-18.2

Subtraction between pointers shall only be applied to pointers that address elements of the same array.

#### 8.2.70.1 只有指向数组或数组元素地址的指针才能进行指针运算 [MISRA2012-RULE-18_2-3]

```c
void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 - p2;   // 违规
    i = p2 - a;    // 违规
    i = p3 - a;    // OK
}
```

### 8.2.71 Rule-18.3

The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object.

#### 8.2.71.2 仅当指针指向同一个数组时才能使用 >, >=, <, <= [MISRA2012-RULE-18_3-3]

```c
void foo( int a[] ) {
    int* p1 = 0;
    int* p2;
    int* p3 = a;
    int i;

    i = p1 < p2;   // 违规
    i = p2 < a;    // 违规
    i = p3 < a;    // 正常
}
```

### 8.2.72 Rule-18.6

The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist.

#### 8.2.72.1 不应该从一个函数中返回一个具有自动存储对象的地址 [MISRA2012-RULE-18_6_a-3]

```c
int* foo1(){
    int i;
    return &i;     // 违规 - 返回了一个本地变量的地址
}

int* foo2(int p) {
    return &p;     //违规 - 返回了一个本地变量的地址
}

int* foo3(){
    int i;
    int* p = &i;
    return p;      //违规 - 返回了一个本地变量的地址
}

int& foo4(){
    int i;
    return i;      // 违规 - 返回了一个本地变量的地址
}
```

#### 8.2.72.2 一个具有自动存储器的对象地址不能够被赋值给另一个对象，那样会导致在第一个对象不复存在时其仍然存留。 [MISRA2012-RULE-18_6_b-3]

```c
int* gp;
void foo1(int** pp){
    static int* sp;
    int i, j;
    int a[4];
    
    gp = &i;        // 违规
    sp = &j;        //  违规
    *pp = a;        // 违规
}

void foo2(){
    int* p;
    {
        int i;
        p = &i;     // 违规
    }
}
```

### 8.2.73 Rule-18.7

Flexible array members shall not be declared.

#### 8.2.73.1 不得声明灵活的数组成员 [MISRA2012-RULE-18_7-3]

```c
struct S
{
    int mv;
    int ma[ ];   /* 违规*/
} str;
```

### 8.2.74 Rule-18.8

Variable-length array types shall not be used.

#### 8.2.74.1 不得使用可变长数组类型 [MISRA2012-RULE-18_8-3]

```c
int n;

void foo(int a[n])         /* 违规*/
{
    int v1[n];             /* 违规*/
    int v2[10][n];         /* 违规*/
    void(*fp)(int ap[n]);  /* 违规*/
}
```

### 8.2.75 Rule-20.2

The ’, ” or  characters and the /* or // character sequences shall not occur in a header file name.

#### 8.2.75.1 字符 ', ", /* 或 // 不得出现在头文件的名称中 [MISRA2012-RULE-20_2_a-3]

```c
#include "fi'le.h" // 违规
```

#### 8.2.75.2 字符 \ 不得出现在头文件的名称中 [MISRA2012-RULE-20_2_b-3]

```c
#include "fi\\le.h" // 违规
```

### 8.2.76 Rule-20.3

The #include directive shall be followed by either a <filename> or ”filename”sequence.

#### 8.2.76.1 #include 指令后面应当添加 <filename> 或是 "filename" [MISRA2012-RULE-20_3-3]

```c
#include foo.h    /* 违规 */
#include <foo1.h> /* OK */
#include "foo2.h" /* OK */
```

### 8.2.77 Rule-20.4

A macro shall not be defined with the same name as a keyword.

#### 8.2.77.1 宏不应该与关键字定义为相同名称 [MISRA2012-RULE-20_4_b-3]

```c
#define int some_other_type          /* 违规  */
#include <stdlib.h>

/* The following example shows that it is non-compliant to redefine the keyword
 * 'while' but it is compliant to define a macro that expands to statements. */

#define while( E ) for ( ; ( E ) ; ) /* 违规 */
#define unless( E ) if ( ! ( E ) )   /* OK */
#define seq( S1, S2 ) do { \
    S1; S2; } while ( false )        /* OK */
#define compound( S ) { S; }         /* OK */
```

### 8.2.78 Rule-20.6

Tokens that look like a preprocessing directive shall not occur within a macro argument.

#### 8.2.78.1 类似函数的宏的参数不应该包含类似预处理命令的标识 [MISRA2012-RULE-20_6-3]

```c
void p(const char *);
#define M( A ) p( #A )

void foo1(int x) 
{
    M (
#ifdef SW                // 违规
          x
#else                    // 违规
          x+1
#endif                   // 违规
      );
}

#define M1(x) x 
void foo2(void) {
    M1 (
#define X 20             // 违规
            X
#                        // 违规
        );
}

#define M2(x) 10
void foo3(void) {
     M2(#X);             // 违规
}
```

### 8.2.79 Rule-20.7

Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses.

#### 8.2.79.1 在函数式宏定义中，每个参数的实例应该被括号括起来，除非它被用于 # 或 ## 操作符 [MISRA2012-RULE-20_7-3]

```c
#define abs(x) ((x >= 0) ? x : -x)          // 违规
#define abs(x) (((x) >= 0) ? (x) : -(x))   // OK
```

### 8.2.80 Rule-20.8

The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1.

在预处理指令 `#if` 或 `#elif` 中，控制表达式必须求值为0或1。这个规则是在C/C++的预处理阶段执行，用于条件编译，目的是确保条件表达式的结果是布尔类型，即只能是0或1，以便根据条件来选择编译哪些代码块。

```c
#define DEBUG_MODE 1
#ifdef DEBUG_MODE
#if DEBUG_MODE == 1
    // 编译这部分代码，因为DEBUG_MODE等于1
    printf("Debug mode is enabled.\n");
#else
    // 如果DEBUG_MODE不等于1，编译这部分代码
    printf("Debug mode is disabled.\n");
#endif
#else
    // 如果DEBUG_MODE未定义，编译这部分代码
    printf("Debug mode is not defined.\n");
#endif
```

### 8.2.81 Rule-20.9

All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before evaluation.

#### 8.2.81.1 除在 #ifdef 和 #ifndef 预处理命令和 defined() 操作符之外，所有的宏标识符在使用前必须定义 [MISRA2012-RULE-20_9_a-3]

```c
#if M > 0        /* 违规 - 宏未定义 */
#endif

#define M 1
#undef M
#if M > 0        /* 违规 - 宏在使用前未定义 */
#endif

#ifdef X
  #define M 1
#endif
#if M > 0        /* 违规 - 宏在定义时附加条件 */
#endif

#if defined(M) && M > 0  /* 违规 - 不支持逻辑表达式 */
#endif

#if defined(M) && defined(N)  /* 不支持逻辑表达式 */
  #if M > 0                   /* 违规 */
  #endif
#endif

#if defined(Q)
  #define M 1
#elif defined(R)
  #define M 2
#endif
#if M > 1   /* 违规 - 宏定义时附加条件*/
#endif
```

```c
#define M1 1
#if M1 > 0        /* OK - macro was defined */
#endif

#undef M1
#ifdef M1
  #if M1 > 0      /* OK - macro is used only if it was defined */
  #endif
#endif

#ifndef M1
//...
#else
  #if M1 > 0      /* OK - macro is used only if it was defined */
  #endif
#endif

#if defined(Q)
  #define M1 1
#elif defined(R)
  #define M1 2
#else
  #define M1 3
#endif
#if M1 > 1   /* OK - macro was defined unconditionally */
#endif

#ifndef M2
#error M2 is not defined
#endif
#if M2 > 0 /* OK - #error directive breaks preprocessing if M2 is not defined */
#endif

#if !defined(M3)
#define M3 1
#endif
#if M3 > 1   /* OK - M3 must be defined */
#endif
```

#### 8.2.81.2 不要使用在编译单元中未定义的预编译器指令 #if 和 #elif 宏 [MISRA2012-RULE-20_9_b-3]

```c
#if M > 0        /* 违规 - 宏未定义 */
#endif

#define M 1
#undef M
#if M > 0        /* 违规 - 宏在使用前未定义 */
#endif

#ifdef X
  #define M 1
#endif
#if M > 0        /* 违规 - 宏定义时附加限制条件 */
#endif

#if defined(M) && M > 0  /* 违规 - 不支持逻辑表达式 */
#endif

#if defined(M) && defined(N)  /* 不支持逻辑表达式 */
  #if M > 0                   /* 违规 */
  #endif
#endif

#if defined(Q)
  #define M 1
#elif defined(R)
  #define M 2
#endif
#if M > 1   /* 违规 - 宏定义附加限制条件 */
#endif
```

```c
#define M1 1

#if M1 > 0        /* OK - macro was defined */
#endif

#undef M1

#ifdef M1
  #if M1 > 0      /* OK - macro is used only if it was defined */
  #endif
#endif

#ifndef M1
//...
#else
  #if M1 > 0      /* OK - macro is used only if it was defined */
  #endif
#endif

#if defined(Q)
  #define M1 1
#elif defined(R)
  #define M1 2
#else
  #define M1 3
#endif
#if M1 > 1   /* OK - macro was defined unconditionally */
#endif

#ifndef M2
#error M2 is not defined
#endif
#if M2 > 0 /* OK - #error directive breaks preprocessing if M2 is not defined */
#endif

#if !defined(M3)
#define M3 1
#endif
#if M3 > 1   /* OK - M3 must be defined */
#endif

/* header.h: */
#define M4 1
#ifndef M5
#if defined(M6)
#endif
#endif
/* source.c: */
#include "header.h"
#if M4 > 1  /* OK - there is #define M4 in header.h */
#endif
#if M5 > 1  /* OK - there is #ifndef M5 in  header.h */
#endif
#if M6 > 1  /* OK - there is #if defined(M6) in header.h */
#endif
```

### 8.2.82 Rule-20.11

A macro parameter immediately following a # operator shall not immediately be followed by a ## operator.

#### 8.2.82.1 一个紧跟在#操作符的宏参数不应该在其后紧跟或在其前加上##操作符 [MISRA2012-RULE-20_11-3]

```c
#define M1( x, y )  #x ## y        /*违规 */
#define M2( x, y )  x ## #y        /* 违规 */
```

### 8.2.83 Rule-20.12

A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators.

#### 8.2.83.1 一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数 [MISRA2012-RULE-20_12-3]

```c
#define AA        0xffff
#define BB(x)     ( x ) + wow ## x
void f(void) {
  int wowAA = 0;
  /*使用wowAA = (0xffff) + wowAA;进行扩展 */
  wowAA = BB(AA);      /* 违规*/
}
```

```c
int speed;
int speed_scale;
int scaled_speed;
#define SCALE(X) ( ( X ) * X ## _scale )
void f(void) {
  /* 扩展到 scaled_speed = ((speed) * speed_scale); */
  scaled_speed = SCALE(speed);
}
```

### 8.2.84 Rule-20.13

A line whose first token is # shall be a valid preprocessing directive.

#### 8.2.84.1 预处理指令即使被预处理器排除也必须有语法意义 [MISRA2012-RULE-20_13-3]

```c
#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else1              /* 违规 */
	x = MAX;
#endif
	return x;
}
```

```c
#define MAX 2

int foo(void)
{
	int x = 0;
	
#ifndef MAX
	x = 1;
#else              /* OK */
	x = MAX;
#endif
	return x;
}
```

### 8.2.85 Rule-20.14

All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related.

#### 8.2.85.1 在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令 [MISRA2012-RULE-20_14-3]

```c
#define A
#ifdef A
#include "file1.h"
#endif
#if 1/* 缺少#endif */
#include "file2.h"
```

### 8.2.86 Rule-21.1

\#define and #undef shall not be used on a reserved identifier or reserved macro name.

#### 8.2.86.1 不要 #define 或 #undef 名称以下划线开始的标识符 [MISRA2012-RULE-21_1_a-3]

```c
#define _foo 1      // 违规
#undef  _bar        // 违规

#define my_foo 1    // OK
#undef  my_foo      // OK
```

#### 8.2.86.2 标准程序库中的保留标识符，宏和函数不应该被定义，重新定义或未定义（C99 代码） [MISRA2012-RULE-21_1_c-3]

```c
#define assert	    // Violation
#undef memset       // Violation

#define my_assert   // OK
#undef my_memset    // OK
```

#### 8.2.86.3 不要使用#define 和 #undef 声明 'defined' [MISRA2012-RULE-21_1_d-3]

```c
#define defined     // 违规
#undef defined      // 违规

#define is_defined     // OK
#undef is_defined      // OK
```

### 8.2.87 Rule-21.2

A reserved identifier or macro name shall not be declared.

#### 8.2.87.1 标准库宏、对象和函数的名称不应该被重用 [MISRA2012-RULE-21_2_a-3]

```c
int _name();    // 违规

int my_name(); // OK
```

#### 8.2.87.2 不应该重复使用标准库中的宏，对象和函数 [MISRA2012-RULE-21_2_c-3]

```c
int memset();    // 违规
int my_memset(); // OK
```

### 8.2.88 Rule-21.3

The memory allocation and deallocation functions of <stdlib.h> shall not be used.

#### 8.2.88.1 禁止使用动态内存分配 [MISRA2012-RULE-21_3-3]

不要使用， 'new' , 'delete', 'calloc', 'malloc','realloc' 和free'函数.

```c
void foo()
{
  int * p = new int[10]; // 违规
  /* ... */
  
  delete[] p;            // 违规
}
```

### 8.2.89 Rule-21.4

The standard header file <setjmp.h> shall not be used.

#### 8.2.89.1 禁止使用 setjmp 宏和 longjmp 函数 [MISRA2012-RULE-21_4_a-3]

```c
#include <setjmp.h>
jmp_buf mark;                       /* long跳转的跳转地址*/
int     fperr;                      /* 全局错误数量 */

void foo( void ) {
    int jmpret;
    jmpret = setjmp( mark );        /* 违规*/
}

void fphandler( int sig, int num ) {
    longjmp( mark, -1 );            /* 违规*/
}
```

#### 8.2.89.2 不要使用标准头文件 <setjmp.h> [MISRA2012-RULE-21_4_b-3]

见“8.2.89.1”

### 8.2.90 Rule-21.5

The standard header file <signal.h> shall not be used.

#### 8.2.90.1 禁止使用标准库文件 <signal.h> 中的处理函数 [MISRA2012-RULE-21_5_a-3]

#### 8.2.90.2 禁止使用信号处理文件 <signal.h> 中的处理函数 [MISRA2012-RULE-21_5_b-3]

### 8.2.91 Rule-21.6

The Standard Library input/output functions shall not be used.

#### 8.2.91.1 不得使用标准的库的 input/output 函数 [MISRA2012-RULE-21_6-3]

```c
#include <stdio.h>

void foo1 ()
{
    char str[20];
    scanf ("%s",str);                 // Violation
    printf("string %s", str);         // Violation
}

void foo2 ()
{
    FILE * pFile;
    pFile = fopen ("myfile.txt","w"); // Violation 
    if (pFile!=NULL)
    {
        fputs ("string",pFile);       // Violation 
        fclose (pFile);               // Violation 
    }
}
```

### 8.2.92 Rule-21.7

The atof, atoi, atol and atoll functions of <stdlib.h> shall not be used.

#### 8.2.92.1 禁止使用 stdlib.h 中库函数 atof, atoi 和 atol [MISRA2012-RULE-21_7-3]

### 8.2.93 Rule-21.8

The library functions abort, exit and system of <stdlib.h> shall not be used.

#### 8.2.93.1 禁止使用 stdlib.h 中的库函数 abort, exit, getenv 和 system [MISRA2012-RULE-21_8-3]

### 8.2.94 Rule-21.9

The library functions bsearch and qsort of <stdlib.h> shall not be used.

#### 8.2.94.1 不得使用在<stdlib.h>中的 bsearch 和 qsort 库函数 [MISRA2012-RULE-21_9-3]

### 8.2.95 Rule-21.10

The Standard Library time and date functions shall not be used.

#### 8.2.95.1 避免使用标准 C 库中与时间有关的函数 [MISRA2012-RULE-21_10-3]

```C
#include <time.h>

void dangerFunction(time_t time);
int main ()
{
  time_t rawtime;
  struct tm * ptm;
  
  time ( &rawtime );          // 违规
  ptm = gmtime ( &rawtime );  // 违规
  dangerFunction(rawtime);

  return 0;
}
```

### 8.2.96 Rule-21.11

The standard header file <tgmath.h> shall not be used.

#### 8.2.96.1 不得使用标准头文件 <tgmath.h> [MISRA2012-RULE-21_11-3]

### 8.2.97 Rule-21.14

The Standard Library function memcmp shall not be used to compare null terminated strings.

不应该使用标准库函数`memcmp`来比较以空字符（null terminated）结尾的字符串。这是因为`memcmp`函数是用来比较内存块的，而不是字符串。它会比较从指定位置开始的一定数量的字节，而不考虑字符串的含义和终止字符。

```c
char str1[] = "Hello";
char str2[] = "Hello";
if (memcmp(str1, str2, 5) == 0) {//违规
    printf("Strings are equal.\n");
} else {
    printf("Strings are not equal.\n");
}
```

### 8.2.98 Rule-21.15

The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types.

标准库函数`memcpy`、`memmove`和`memcmp`的指针参数应该是指向具有兼容类型的限定或非限定版本的指针。

```c
int source[] = {1, 2, 3, 4, 5};
double destination[5];
memcpy(destination, source, sizeof(source));//违规
memcpy(destination, (double*)source, sizeof(source));//OK
```

### 8.2.99 Rule-21.16

The pointer arguments to the Standard Library function memcpy shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type.

标准库函数`memcpy`的指针参数应该指向以下类型之一：指针类型、本质上是有符号的类型、本质上是无符号的类型、本质上是布尔类型或本质上是枚举类型。

### 8.2.100 Rule-22.1

All resources obtained dynamically by means of Standard Library functions shall be explicitly released.

#### 8.2.100.1 确保资源已释放 [MISRA2012-RULE-22_1-3]

```c
#include <stdio.h>

static void fileAllocation()
{
	FILE* p = fopen("file.name", "r");//违规 无fclose
}

static void fileReallocation()
{
	FILE* p = fdopen(0, "file.name");
	p = freopen("file.name", "r", p);
    //违规 无fclose
}
```

### 8.2.101 Rule-22.3

The same file shall not be open for read and write access at the same time on different streams.

在不同的数据流上，同一个文件不应该同时以读取和写入的方式打开。这是为了避免数据一致性问题和潜在的文件损坏风险。当一个文件同时以读取和写入的方式打开时，可能会导致不可预测的行为，如数据丢失或损坏。

```c
#include <stdio.h>

int main() {
    FILE *file1, *file2;
    
    file1 = fopen("example.txt", "r"); 
    file2 = fopen("example.txt", "w"); //违规-同时读取和写入的方式打开同一文件
    
    if (file1 == NULL || file2 == NULL) {
        printf("Failed to open files.\n");
        return 1;
    }
    // 这里进行读取和写入操作...
    fclose(file1);
    fclose(file2);
    
    return 0;
}

```

### 8.2.102 Rule-22.7

The macro EOF shall on ly be compared with the unmodified return value from any Standard Library function capable of returning EOF.

宏`EOF`应该只与能够返回`EOF`的未修改返回值进行比较，而不应与其他值进行比较。`EOF`是一个常用于表示文件结束的宏，在C语言中通常定义为一个负数。

```c
#include <stdio.h>

int main() {
    int c = getchar();

    if (c == -1) {  // 这是违规的，应该使用 EOF 而不是 -1
        printf("End of file encountered.\n");
    } else {
        printf("Character entered: %c\n", c);
    }

    return 0;
}

```

### 8.2.103 Rule-22.8

The value of errno shall be set to zero prior to a call to an errno-setting-function.

在调用设置`errno`的函数之前，应该将`errno`的值设置为零。`errno`是一个特殊的错误码，用于标识函数调用是否发生了错误，并提供了更多关于错误类型的信息。

```c
#include <stdio.h>
#include <errno.h>

int main() {
    errno = 0;  // 将 errno 的值设置为零

    FILE *file = fopen("nonexistent_file.txt", "r");

    if (file == NULL) {
        printf("Error opening file. Errno: %d\n", errno);
    } else {
        printf("File opened successfully.\n");
    }

    return 0;
}

```



### 8.2.104 Rule-22.9

The value of errno shall be tested against zero after calling an errno-setting-function.

在调用设置`errno`的函数之后，应该检查`errno`的值是否为零，以确定函数调用是否引发了错误。`errno`是一个特殊的错误码，用于标识函数调用是否发生了错误，并提供了更多关于错误类型的信息。

### 8.2.105 Rule-22.10

The value of errno shall only be tested when the last function to be called was an errno-setting-function.

只有在最后一个被调用的函数是一个可以设置`errno`的函数时，才应该测试`errno`的值。